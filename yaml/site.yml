---
# Ansible Automation Platform - Execution Environment Builder
# This playbook builds customized execution environments based on Red Hat AAP base images.
- name: Setup and store credentials
  hosts: localhost
  connection: local
  gather_facts: true
  environment:
    ANSIBLE_LOCALHOST_WARNING: "False" 
    ANSIBLE_DEPRECATION_WARNINGS: "False"
    ANSIBLE_COMMAND_WARNINGS: "False"
    ANSIBLE_SYSTEM_WARNINGS: "False"

  vars:
    container_registries:
      - registry.redhat.io
      - registry.access.redhat.com
      - registry.connect.redhat.com

    required_images:
      - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8
      - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9
      - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8
      - registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9
      - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8
      - registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9
      - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8
      - registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9

    protected_images:
      - "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest"
      - "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9"
      - "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9:latest"
      - "rhel9-de-minimal"
      - "rhel9-de-minimal-cloudstrike"
      - "rhel9-de-supported"
      - "rhel9-ee-minimal"
      - "rhel9-ee-minimal-cloud"
      - "rhel9-ee-minimal-general"
      - "rhel9-ee-minimal-vmware"
      - "rhel9-ee-minimal-windows"
      - "rhel9-ee-supported"
      - "rhel9-ee-supported-vmware"

    dns_servers:
      - '8.8.8.8'
      - '8.8.4.4'

    required_packages:
      - ansible-builder
      - ansible-core
      - autoconf
      - automake
      - bison
      - gcc
      - git
      - make
      - ncurses
      - podman
      - podman-docker
      - python3-pip
      - tmux
      - xdg-utils
      - yum-utils

    update_protected_list: true

    scripts_dir: "{{ playbook_dir }}/scripts"
    tasks_dir: "{{ playbook_dir }}/tasks"
    template_dir: "{{ playbook_dir }}/templates"
    environment_dir: "{{ playbook_dir }}/environments"
    terminal_script: "{{ scripts_dir }}/open_terminal.sh"
    monitor_script: "{{ scripts_dir }}/start_monitor.sh"
    process_env_task: "{{ tasks_dir }}/process_environment.yml"

  tasks:
    - name: Verify internet connectivity  
      ansible.builtin.uri:
        url: https://google.com
        method: GET
      register: connectivity_check
      failed_when: connectivity_check.status != 200  
      changed_when: false
      tags: [connectivity, validation, init]
      
    # Create static ansible.cfg before any template processing
    - name: Create static ansible.cfg file for initial setup
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/ansible.cfg"
        mode: '0644'
        force: false  # Don't overwrite if exists
        content: |
          [defaults]
          inventory = localhost,
          ansible_localhost_warning=false
          ansible_deprecation_warnings=false
          force_color = True

          [galaxy]
          server_list = validated, published, galaxy

          [galaxy_server.published]
          url=https://console.redhat.com/api/automation-hub/content/published/
          auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

          [galaxy_server.validated]
          url=https://console.redhat.com/api/automation-hub/content/validated/
          auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

          [galaxy_server.galaxy]
          url=https://galaxy.ansible.com/
      tags: [always, setup, init]

    - name: Create collections requirements file
      ansible.builtin.copy:
        dest: "/tmp/requirements.yml"
        mode: '0644'
        content: |
          ---
          collections:
            - name: ansible.utils
            - name: ansible.posix
            - name: community.general
            - name: infra.aap_configuration
            - name: infra.aap_utilities
      tags: [setup, always, collections, init]

    - name: Create requirements.txt file
      ansible.builtin.copy:
        dest: "/tmp/requirements.txt"
        mode: '0644'
        content: |
          ansible-builder>=3.0.0
          ansible-core>=2.15.0,<2.16
          ansible-lint>=24.0.0
      tags: [setup, always, collections, init]

    - name: Create inventory file
      ansible.builtin.copy:
        dest: "/tmp/inventory"
        force: false
        state: present
        mode: '0644'
        content: |
          [devnode]
          localhost ansible_connection=localhost
      tags: [always, setup, init]
     
    - name: Force install community.general collection system-wide
      ansible.builtin.command:
        cmd: "sudo ansible-galaxy collection install community.general ansible.posix -p /usr/share/ansible/collections --force"
      register: galaxy_install
      changed_when: galaxy_install.rc == 0
      failed_when: galaxy_install.rc != 0
      tags: [setup, init]

    - name: Verify community.general collection installation
      ansible.builtin.command:
        cmd: "ansible-galaxy collection list community.general"
      register: collection_verify
      failed_when: collection_verify.rc != 0
      tags: [setup, validation, init]

    - name: Show installation path
      ansible.builtin.debug:
        msg: "Collection installed at: {{ collection_verify.stdout_lines | select('search', 'Path:') | first | default('Unknown location') }}"
      tags: [setup, init]

    # Improved user detection logic
    - name: Get effective and real user info
      ansible.builtin.shell: |
        echo "EUID=$(id -u)"
        if [ -n "$SUDO_USER" ]; then
          echo "SUDO_USER=$SUDO_USER"
          echo "SUDO_UID=$(id -u $SUDO_USER)"
          echo "SUDO_HOME=$(eval echo ~$SUDO_USER)"
        else
          echo "SUDO_USER="
          echo "SUDO_UID="
          echo "SUDO_HOME="
        fi
        echo "USER=$(whoami)"
        echo "HOME=$HOME"
      register: user_info_output
      changed_when: false
      tags: [always, init]
    
    - name: Parse user info
      ansible.builtin.set_fact:
        parsed_user_info: "{{ dict(user_info_output.stdout_lines | map('regex_replace', '^([^=]+)=(.*)$', '\\1:\\2') | map('split', ':') | list) }}"
      tags: [always, init]
    
    - name: Set user facts
      ansible.builtin.set_fact:
        is_root: "{{ ansible_user_id == '0' }}"
        actual_user: "{{ ansible_user_id }}"
        user_home: "{{ ansible_env.HOME }}"
      tags: [always, init]
    
    - name: Set current_user fact
      ansible.builtin.set_fact:
        current_user: "{{ actual_user }}"
      tags: [always, init]
    
    - name: Debug user detection
      ansible.builtin.debug:
        msg: |
          User detection results:
          - Effective UID: {{ parsed_user_info.EUID }}
          - Running as root: {{ is_root }}
          - Original user: {{ actual_user }}
          - User home: {{ user_home }}
      tags: [always, init]

    # Skip credential setup if running as root directly (not via sudo)
    - name: Skip credential setup if running as root directly
      ansible.builtin.set_fact:
        skip_credential_setup: "{{ ansible_user_id == 'root' and lookup('env', 'SUDO_USER') == '' }}"
      tags: [always, creds]

    - name: Skip credential setup for testing
      ansible.builtin.set_fact:
        skip_credential_setup: true
      tags: [always, creds]

    - name: Show credential setup status
      ansible.builtin.debug:
        msg: "{{ skip_credential_setup | ternary('Running as direct root user - skipping credential setup', 'Setting up credentials for user ' + actual_user) }}"
      tags: [always, creds]

    - name: Setup user credentials properly
      when: not skip_credential_setup
      block:
        - name: Ensure ansible vars directory exists in user's home
          ansible.builtin.file:
            path: "{{ user_home }}/.ansible/vars"
            state: directory
            mode: '0700'
          tags: [setup, credential_setup, creds]

        - name: Check if credentials file exists
          ansible.builtin.stat:
            path: "{{ user_home }}/.ansible/vars/config"
          register: config_file
          tags: [always, creds]

        - name: Fix permissions on credential directory if needed
          ansible.builtin.shell: |
            mkdir -p "{{ user_home }}/.ansible/vars"
            chmod 0700 "{{ user_home }}/.ansible"
            chmod 0700 "{{ user_home }}/.ansible/vars"
            touch "{{ user_home }}/.ansible/vars/config"
            chmod 0600 "{{ user_home }}/.ansible/vars/config"
          when: config_file is failed or not config_file.stat.exists
          changed_when: true
          tags: [always, creds]

        - name: Create empty config file if it doesn't exist
          ansible.builtin.copy:
            dest: "{{ user_home }}/.ansible/vars/config"
            force: false
            content: |
              ---
              # Ansible EE Builder Configuration - Last updated {{ ansible_date_time.iso8601 }}
              rh_username: ''
              rh_password: ''
              automation_hub_token: ''
              galaxy_token: ''
            mode: '0600'
          when: not config_file.stat.exists
          tags: [setup, credential_setup, creds]

        - name: Load stored credentials
          ansible.builtin.include_vars:
            file: "{{ user_home }}/.ansible/vars/config"
            name: stored_credentials
          tags: [always, creds]

        - name: Check if config file has required variables
          ansible.builtin.set_fact:
            has_rh_username: "{{ stored_credentials.rh_username is defined and stored_credentials.rh_username != '' }}"
            has_rh_password: "{{ stored_credentials.rh_password is defined and stored_credentials.rh_password != '' }}"
            has_automation_hub_token: "{{ stored_credentials.automation_hub_token is defined }}"
            has_galaxy_token: "{{ stored_credentials.galaxy_token is defined }}"
          tags: [always, creds]

        - name: Collect Red Hat CDN username if missing
          ansible.builtin.pause:
            prompt: "Enter your Red Hat CDN username"
            echo: true
          register: rh_username_input
          when: not has_rh_username
          tags: [creds]
              
        - name: Collect Red Hat CDN password if missing
          ansible.builtin.pause:
            prompt: "Enter your Red Hat CDN password"
            echo: false
          register: rh_password_input
          when: not has_rh_password
          no_log: false
          tags: [creds]
              
        - name: Collect Automation Hub token if missing
          ansible.builtin.pause:
            prompt: "Enter your Automation Hub token (or press enter to skip)"
            echo: false
          register: automation_hub_token_input
          when: not has_automation_hub_token
          no_log: false
          tags: [creds]
              
        - name: Collect Galaxy token if missing
          ansible.builtin.pause:
            prompt: "Enter your Galaxy token (or press enter to skip)"
            echo: false
          register: galaxy_token_input
          when: not has_galaxy_token
          no_log: false
          tags: [creds]
              
        - name: Update credentials while preserving existing values
          ansible.builtin.set_fact:
            rh_username: "{{ rh_username_input.user_input if (rh_username_input is defined and rh_username_input.user_input is defined) else stored_credentials.rh_username | default('') }}"
            rh_password: "{{ rh_password_input.user_input if (rh_password_input is defined and rh_password_input.user_input is defined) else stored_credentials.rh_password | default('') }}"
            automation_hub_token: "{{ automation_hub_token_input.user_input if (automation_hub_token_input is defined and automation_hub_token_input.user_input is defined) else stored_credentials.automation_hub_token | default('') }}"
            galaxy_token: "{{ galaxy_token_input.user_input if (galaxy_token_input is defined and galaxy_token_input.user_input is defined) else stored_credentials.galaxy_token | default('') }}"
          no_log: false
          tags: [creds]

        - name: Save updated credentials to file (preserving existing values)
          block:
            - name: Ensure ansible vars directory exists with correct permissions
              ansible.builtin.file:
                path: "{{ user_home }}/.ansible/vars"
                state: directory
                mode: '0700'
                owner: "{{ actual_user }}"
              become: "{{ is_root }}"
              
            - name: Create credentials file with proper permissions
              ansible.builtin.shell: |
                cat > "{{ user_home }}/.ansible/vars/config" << 'EOL'
                ---
                # Ansible EE Builder Configuration - Last updated {{ ansible_date_time.iso8601 }}
                rh_username: '{{ rh_username }}'
                rh_password: '{{ rh_password }}'
                automation_hub_token: '{{ automation_hub_token }}'
                galaxy_token: '{{ galaxy_token }}'
                EOL
                chmod 0600 "{{ user_home }}/.ansible/vars/config"
              args:
                executable: /bin/bash
              changed_when: true
          rescue:
            - name: Handle credentials file creation failure
              ansible.builtin.debug:
                msg: "Failed to save credentials file. Using fallback method."
          tags: [creds]

        - name: Show run mode
          ansible.builtin.debug:
            msg: |
              ┌────────────────────────────────────────────────────────────────────┐
              │                     RUN MODE INFORMATION                           │
              ├────────────────────────────────────────────────────────────────────┤
              │ {{ "FIRST RUN DETECTED: Running full setup" if first_run | default(false) else "SUBSEQUENT RUN: Using stored configuration" }} │
              │                                                                    │
              │ User: {{ actual_user | default('Unknown') }}                                            │
              │ Credentials: {{ "New" if first_run | default(false) else "Loaded from file" }}      │
              └────────────────────────────────────────────────────────────────────┘
          tags: [always, creds]

        # Use sudo_user's home directory for config in the main play
        - name: Set config path for main play
          ansible.builtin.set_fact:
            config_path: "{{ user_home }}/.ansible/vars/config"
          tags: [always, creds]

    - name: Check if credentials template file exists
      ansible.builtin.stat:
        path: "{{ playbook_dir }}/templates/config.j2"
      register: template_file
      tags: [setup, creds, init]

    - name: Create credentials template file
      ansible.builtin.copy:
        dest: "{{ playbook_dir }}/templates/config.j2"
        force: false
        mode: '0600'
        content: |
          ---
          # Ansible EE Builder Configuration - Last updated {{ ansible_date_time.iso8601 }}
          rh_username: '{{ rh_username }}'
          rh_password: '{{ rh_password }}'
          automation_hub_token: '{{ automation_hub_token }}'
          galaxy_token: '{{ galaxy_token }}'
      when: not template_file.stat.exists
      tags: [setup, creds, init]

# Play 2: Display title and introduction
- name: Display title screen
  hosts: localhost
  connection: local
  gather_facts: false
  environment:
    ANSIBLE_LOCALHOST_WARNING: "False" 
    ANSIBLE_DEPRECATION_WARNINGS: "False"
    ANSIBLE_COMMAND_WARNINGS: "False"
    ANSIBLE_SYSTEM_WARNINGS: "False"
  tasks:
    - name: Show ascii title
      ansible.builtin.debug:
        msg: |
          ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
          │                                                                                      ..:-=@@@@=-:..          │
          │                                                                                    .*%@@@@@@@@@@@@%*.        │
          │                                                                                 .:@@@@@@@@@@@@@@@@@@@@:.     │
          │                                                                                .*@@@@@@@@@@*-@@@@@@@@@@*.    │
          │                                                                               .@@@@@@@@@@@*. =@@@@@@@@@@@.   │
          │                                                                              .%@@@@@@@@@@@ .@ +@@@@@@@@@@%.  │
          │                                                                              -%@@@@@@@@@@..@%-.*@@@@@@@@@%-  │
          │     "A Streamlined Approach to Building Ansible Execution Environments"     .+@@@@@@@@@@= =@@@.:@@@@@@@@@@+. │
          │                                                                             .+@@@@@@@@@@ ..:+@%.-@@@@@@@@@+. │
          │                                                                             .=@@@@@@@@@ .@@+. *+.-@@@@@@@%=  │
          │                                                                              .%@@@@@@@:.*@@@@%.  .+@@@@@@%.  │
          │                                                                               .@@@@@@= =@@@@@@@%=.:%@@@@@.   │
          │                                                                                :%@@@@@@@@@@@@@@@@@@@@@@%:    │
          │                                                                                 .*@@@@@@@@@@@@@@@@@@@@*.     │
          │                                                                                   .+@@@@@@@@@@@@@@@@+..      │
          │                                                                                     ..+*%@@@@@@%*+..         │
          └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
      tags: [always, init]

    - name: Title screen
      ansible.builtin.pause:
        seconds: 3
      tags: [always, init]

# Play 3: Environment Selection and Build Process
- name: Environment Selection and Build Process
  hosts: localhost
  connection: local
  gather_facts: false
  vars:
    scripts_dir: "{{ playbook_dir }}/scripts"
    tasks_dir: "{{ playbook_dir }}/tasks"
    template_dir: "{{ playbook_dir }}/templates"
    environment_dir: "{{ playbook_dir }}/environments"
    terminal_script: "{{ scripts_dir }}/open_terminal.sh"
    monitor_script: "{{ scripts_dir }}/start_monitor.sh"
    process_env_task: "{{ tasks_dir }}/process_environment.yml"
  tasks:
    # Add WSL detection at the beginning
    - name: Determine if running in WSL (global)
      ansible.builtin.shell: |
        grep -q Microsoft /proc/version 2>/dev/null || grep -q WSL /proc/version 2>/dev/null
      register: is_wsl_global
      changed_when: false
      failed_when: false
      tags: [always]
      
    - name: Set global WSL fact
      ansible.builtin.set_fact:
        is_wsl_env: "{{ is_wsl_global.rc == 0 }}"
      tags: [always]

    - name: Create all required directories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        # Playbook structure directories
        - "{{ playbook_dir }}/scripts"
        - "{{ playbook_dir }}/library"
        - "{{ playbook_dir }}/tasks"
        - "{{ playbook_dir }}/templates"
        - "{{ playbook_dir }}/files"
    
        # Runtime directories
        - "/tmp/ee-containers"
        - "/tmp/ee-containers/context"
        - "/tmp/ee-containers/context/environments"
        - "/tmp/ee-containers/_build"
    
        # Ansible configuration directories
        - "~/.ansible"
        - "~/.ansible/vars"
        - "~/.ansible/tmp"
      tags: [setup, init, pre_reqs]

    - name: Create all required project files
      block:
        - name: Create start_monitor.sh script
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/scripts/start_monitor.sh"
            force: false
            mode: '0755'
            content: |
              #!/bin/bash
              {% raw %}
              # Kill any existing session to ensure clean slate
              tmux kill-session -t podman-monitor 2>/dev/null || true

              # Create initial status file with default message
              echo "NOTHING BUILDING YET" > /tmp/current_env

              # Create new session with dynamic dimensions
              tmux new-session -d -s podman-monitor

              # Split window into three panes with optimized sizes:
              tmux split-window -v -t podman-monitor:0.0 -p 85
              tmux split-window -v -t podman-monitor:0.1 -p 5

              # Top pane: ASCII art header
              tmux select-pane -t podman-monitor:0.0
              tmux send-keys -t podman-monitor:0.0 "clear; cat << 'EOF'
              ┌──────────────────────────────────────────────────────────────────────────┐
              │              ●●●●●●●                                                     │
              │             ●●●●●●●●●                                                    │
              │            ●●●●●●●●●●●                                                   │
              │    ╔══════●●●●●●═●●●●●●══════╗                                           │
              │    ║     ●●●●●●    ●●●●●● NSIBLE & PODMAN                                │
              │    ║    ●●●●●●      ●●●●●●    ║ EXECUTION ENVIRONMENT BUILD MONITOR      │
              │    ╚═══●●●●●●════════●●●●●●═══╝                                          │
              └──────────────────────────────────────────────────────────────────────────┘
              EOF
              " C-m

              # Middle pane: Single-line status display
              tmux select-pane -t podman-monitor:0.1
              tmux send-keys -t podman-monitor:0.1 'while true; do
                clear
                BUILDING_FILE=/tmp/current_env
                if [ -f "$BUILDING_FILE" ]; then
                  BUILDING_ENV=$(cat "$BUILDING_FILE")
                  
                  OUTPUT="$BUILDING_ENV"
                  
                  if [[ "$BUILDING_ENV" != "SKIPPED"* && 
                        "$BUILDING_ENV" != "COMPLETED"* && 
                        "$BUILDING_ENV" != "NOTHING BUILDING YET" && 
                        "$BUILDING_ENV" != "FAILED"* ]]; then
                    SPINNER_CHARS=("|" "/" "-" "\\")
                    SPINNER_INDEX=$(( (SECONDS / 1) % 4 ))
                    SPINNER=${SPINNER_CHARS[$SPINNER_INDEX]}
                    OUTPUT="⏳ Building: $BUILDING_ENV ${SPINNER}"
                  elif [[ "$BUILDING_ENV" == "FAILED"* ]]; then
                    OUTPUT="❌ $BUILDING_ENV"
                  elif [[ "$BUILDING_ENV" == "COMPLETED"* ]]; then
                    OUTPUT="✅ $BUILDING_ENV"
                  elif [[ "$BUILDING_ENV" == "NOTHING BUILDING YET" ]]; then
                    OUTPUT="💤 $BUILDING_ENV"
                  fi
                  
                  COLS=$(tput cols)
                  printf "%*s\n" $(( (${#OUTPUT} + COLS) / 2 )) "$OUTPUT"
                else
                  COLS=$(tput cols)
                  MSG="NOTHING BUILDING YET"
                  printf "%*s\n" $(( (${#MSG} + COLS) / 2 )) "💤 $MSG"
                fi
                sleep 0.5
              done' C-m

              # Bottom pane: Use faster refresh for podman images
              tmux select-pane -t podman-monitor:0.2
              tmux send-keys -t podman-monitor:0.2 'watch -n .05 podman images' C-m

              echo "Monitor session started. Use 'tmux attach -t podman-monitor' to view."
              {% endraw %}
          tags: [setup, files, monitoring]

        - name: Create templates directory and files
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/templates/assemble.sh.j2"
            force: false
            mode: '0755'
            content: |
              #!/bin/bash
              set -ex
              
              {% raw %}
              echo "Running custom assemble script for {{ item | basename }}"
              
              # Use proper package manager based on availability
              if command -v microdnf &> /dev/null; then
                  PKG_MGR="microdnf"
              elif command -v dnf &> /dev/null; then
                  PKG_MGR="dnf"
              else
                  PKG_MGR="yum"
              fi
              
              echo "Using package manager: $PKG_MGR"
              
              # Install any required system packages
              if [ -f /tmp/src/bindep.txt]; then
                  echo "Installing packages from bindep.txt"
                  $PKG_MGR install -y $(cat /tmp/src/bindep.txt | grep -v "^#" | xargs)
              fi
              
              # Install Python requirements
              if [ -f /tmp/src/requirements.txt]; then
                  echo "Installing Python requirements"
                  {% endraw %}
                  {% raw %}{% if "terraform" in (item | basename) %}{% endraw %}
                  # Fix terraform requirements
                  echo "Original requirements.txt:"
                  cat /tmp/src/requirements.txt
                  grep -v -- "--exclude" /tmp/src/requirements.txt > /tmp/requirements.clean.txt
                  echo "Cleaned requirements.txt:"
                  cat /tmp/requirements.clean.txt
                  pip3 install --no-cache-dir -r /tmp/requirements.clean.txt
                  {% raw %}{% else %}{% endraw %}
                  pip3 install --no-cache-dir -r /tmp/src/requirements.txt
                  {% raw %}{% endif %}{% endraw %}
              fi
              
              # Add environment-specific customizations
              {% raw %}{% if "terraform" in (item | basename) %}{% endraw %}
              echo "Adding Terraform-specific configuration"
              $PKG_MGR install -y unzip curl wget which
              TERRAFORM_VERSION="1.5.7"
              cd /tmp
              curl -LO "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip"
              unzip -o "terraform_${TERRAFORM_VERSION}_linux_amd64.zip"
              mv terraform /usr/local/bin/
              chmod +x /usr/local/bin/terraform
              pip3 install --no-cache-dir terraform-provider python-terraform
              {% raw %}{% endif %}{% endraw %}
              
              {% raw %}{% if "servicenow" in (item | basename) %}{% endraw %}
              echo "Adding ServiceNow-specific configuration"
              pip3 install --no-cache-dir pysnow servicenow_client
              {% raw %}{% endif %}{% endraw %}
              
              echo "Custom assemble script completed successfully"
              exit 0
          tags: [setup, files]

        - name: Create task files
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/tasks/process_environment.yml"
            force: false
            mode: '0644'
            content: |
              {% raw %}
              ---
              # This file is generated dynamically by site.yml
              # Tasks for processing individual execution environments

              - name: Get environment name
                ansible.builtin.set_fact:
                  env_name: "{{ ee_environment | basename }}"  # Use ee_environment, not environment
                  
              - name: Update current build status for monitoring
                ansible.builtin.copy:
                  dest: /tmp/current_env
                  content: "Building: {{ env_name }}"
                  mode: '0644'
                changed_when: true

              - name: Extract base image information
                ansible.builtin.shell: |
                  grep -A 3 "base_image:" "{{ ee_environment }}/execution-environment.yml" | grep "name:" | awk -F"'" '{print $2}' | tr -d "'"  # Changed from environment to ee_environment
                register: base_image_info
                changed_when: false

              - name: Login to registry for this image
                ansible.builtin.shell: |
                  REGISTRY=$(echo "{{ base_image_info.stdout }}" | cut -d'/' -f1)
                  if [ ! -z "$REGISTRY" ]; then
                    echo "Logging into registry: $REGISTRY"
                    podman login $REGISTRY -u '{{ rh_username | default("") }}' -p '{{ rh_password | default("") }}' --tls-verify=false
                  fi
                register: registry_login
                no_log: true
                failed_when: false
                when: base_image_info.stdout | length > 0

              - name: Pull the base image directly
                ansible.builtin.shell: |
                  podman pull --tls-verify=false "{{ base_image_info.stdout }}"
                register: image_pull
                changed_when: image_pull.rc == 0
                failed_when: false

              - name: Create execution environment directory
                ansible.builtin.file:
                  path: "/tmp/ee-containers/context/environments/{{ env_name }}"
                  state: directory
                  mode: '0755'

              - name: Create scripts directory for execution environment
                ansible.builtin.file:
                  path: "/tmp/ee-containers/context/environments/{{ env_name }}/scripts"
                  state: directory
                  mode: '0755'

              - name: Ensure assemble script content
                ansible.builtin.template:
                  src: "{{ playbook_dir }}/templates/assemble.sh.j2"
                  dest: "/tmp/ee-containers/context/environments/{{ env_name }}/scripts/assemble"
                  mode: '0755'
                  vars:
                    item: "{{ ee_environment }}"  # ADD THIS LINE to pass ee_environment as item to the template

              - name: Copy environment files to build context
                ansible.builtin.shell: |
                  cp -r {{ ee_environment }}/* /tmp/ee-containers/context/environments/{{ env_name }}/  # Changed from environment to ee_environment
                changed_when: true

              - name: Build execution environment image
                ansible.builtin.shell: |
                  cd /tmp/ee-containers/context/environments/{{ env_name }} && \
                  ansible-builder build \
                    --tag {{ env_name }} \
                    --container-runtime podman \
                    --verbosity 2 \
                    --prune-images \
                    --context . \
                    -f execution-environment.yml
                register: build_result
                failed_when: build_result.rc != 0
                changed_when: build_result.rc == 0

              - name: Record build result
                ansible.builtin.set_fact:
                  build_status: "{{ build_result.rc == 0 }}"
                  build_output: "{{ build_result }}"
                changed_when: false

              - name: Update status file with completion
                ansible.builtin.copy:
                  dest: /tmp/current_env
                  content: "COMPLETED: {{ env_name }}"
                  mode: '0644'
                changed_when: true
                when: build_status
                
              - name: Update status file with failure
                ansible.builtin.copy:
                  dest: /tmp/current_env
                  content: "FAILED: {{ env_name }}"
                  mode: '0644'
                changed_when: true
                when: not build_status

              {% endraw %}
          tags: [setup, files]

        - name: Create library directory and custom module
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/library/podman_image_info.py"
            force: false
            mode: '0755'
            content: |
              #!/usr/bin/python
              
              # Copyright: (c) 2023, Your Name <your.email@example.com>
              # GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
              
              from __future__ import (absolute_import, division, print_function)
              __metaclass__ = type
              
              DOCUMENTATION = r'''
              ---
              module: podman_image_info
              short_description: Gather information about Podman images
              description:
                  - Gather information about Podman images.
                  - Lists images and their attributes.
              options:
                  name:
                      description:
                          - Filter by image name.
                      type: str
                      required: false
                  tag:
                      description:
                          - Filter by image tag.
                      type: str
                      required: false
              author:
                  - "Your Name (@yourGitHubHandle)"
              '''
              
              EXAMPLES = r'''
              - name: Get info about all images
                podman_image_info:
                register: image_info
              
              - name: Get info about a specific image
                podman_image_info:
                  name: registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8
                register: specific_image_info
              '''
              
              RETURN = r'''
              images:
                  description: List of image dictionaries
                  returned: always
                  type: list
                  elements: dict
                  contains:
                      id:
                          description: Image ID
                          type: str
                          sample: "sha256:f9a9f253f6798722d9e692c2b1429aa1"
                      names:
                          description: Image names and tags
                          type: list
                          sample: ["registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8:latest"]
                      created:
                          description: When the image was created
                          type: str
                          sample: "2023-04-20T10:15:30Z"
                      size:
                          description: Image size in bytes
                          type: int
                          sample: 358974135
              '''
              
              import json
              import re
              import subprocess
              
              from ansible.module_utils.basic import AnsibleModule
              
              
              def run_command(module, command):
                  """Run a Podman command and return the output."""
                  try:
                      result = subprocess.run(
                          command,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE,
                          check=False,
                          universal_newlines=True
                      )
                      if result.returncode != 0:
                          module.fail_json(
                              msg="Failed to execute command",
                              command=command,
                              stdout=result.stdout,
                              stderr=result.stderr,
                              rc=result.returncode
                          )
                      return result.stdout
                  except Exception as e:
                      module.fail_json(msg=f"Command execution error: {e}", command=command)
              
              
              def get_image_info(module, name=None, tag=None):
                  """Get image information using podman images."""
                  command = ["podman", "images", "--format", "json"]
                  
                  if name:
                      command.append(name)
                      if tag:
                          command[-1] = f"{name}:{tag}"
                  
                  output = run_command(module, command)
                  
                  try:
                      return json.loads(output)
                  except json.JSONDecodeError:
                      module.fail_json(msg="Failed to parse podman images output", output=output)
              
              
              def main():
                  """Main module function."""
                  module_args = {
                      'name': {'type': 'str', 'required': False},
                      'tag': {'type': 'str', 'required': False}
                  }
                  
                  result = {'changed': False}
                  module = AnsibleModule(argument_spec=module_args, supports_check_mode=True)
                  
                  # In check mode, return empty list
                  if module.check_mode:
                      result['images'] = []
                      module.exit_json(**result)
                  
                  name = module.params['name']
                  tag = module.params['tag']
                  
                  result['images'] = get_image_info(module, name, tag)
                  module.exit_json(**result)
              
              
              if __name__ == '__main__':
                  main()
          tags: [setup, files]

        - name: Create files directory and content
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/files/build-banner.txt"
            force: false
            mode: '0644'
            content: |
              ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
              │                                                                                      ..:-=@@@@=-:..          │
              │                                                                                    .*%@@@@@@@@@@@@%*.        │
              │                                                                                 .:@@@@@@@@@@@@@@@@@@@@:.     │
              │                                                                                .*@@@@@@@@@@*-@@@@@@@@@@*.    │
              │                                                                               .@@@@@@@@@@@*. =@@@@@@@@@@@.   │
              │                                                                              .%@@@@@@@@@@@ .@ +@@@@@@@@@@%.  │
              │                                                                              -%@@@@@@@@@@..@%-.*@@@@@@@@@%-  │
              │     "A Streamlined Approach to Building Ansible Execution Environments"     .+@@@@@@@@@@= =@@@.:@@@@@@@@@@+. │
              │                                                                             .+@@@@@@@@@@ ..:+@%.-@@@@@@@@@+. │
              │                                                                             .=@@@@@@@@@ .@@+. *+.-@@@@@@@%=  │
              │                                                                              .%@@@@@@@:.*@@@@%.  .+@@@@@@%.  │
              │                                                                               .@@@@@@= =@@@@@@@%=.:%@@@@@.   │
              │                                                                                :%@@@@@@@@@@@@@@@@@@@@@@%:    │
              │                                                                                 .*@@@@@@@@@@@@@@@@@@@@*.     │
              │                                                                                   .+@@@@@@@@@@@@@@@@+..      │
              │                                                                                     ..+*%@@@@@@%*+..         │
              └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
          tags: [setup, files]
          
        - name: Create sample environment files (if directory is empty)
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/environments/rhel8-ee-minimal/execution-environment.yml"
            force: false # Don't overwrite if exists
            mode: '0644'
            content: |
              ---
              version: 3
              
              images:
                base_image:
                  name: registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8:latest
              
              dependencies:
                python:
                  - kubernetes>=12.0.0
                  - PyYAML>=5.1
                  - jmespath>=1.0.0
                system:
                  - which
                galaxy:
                  collections:
                    - ansible.builtin
                    - community.general
              
              additional_build_steps:
                prepend_base:
                  - USER root
                  - COPY scripts/assemble /output/scripts/assemble
                  - RUN chmod +x /output/scripts/assemble
          tags: [setup, files]
          
        - name: Create rhel9 sample environment
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/environments/rhel9-ee-minimal/execution-environment.yml"
            force: false
            content: |
              ---
              version: 3
              
              images:
                base_image:
                  name: registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest
              
              dependencies:
                python:
                  - kubernetes>=12.0.0
                  - PyYAML>=5.1
                  - jmespath>=1.0.0
                system:
                  - which
                galaxy:
                  collections:
                    - ansible.builtin
                    - community.general
              
              additional_build_steps:
                prepend_base:
                  - USER root
                  - COPY scripts/assemble /output/scripts/assemble
                  - RUN chmod +x /output/scripts/assemble
          tags: [setup, files]
          
        - name: Create terraform sample environment
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/environments/rhel8-ee-minimal-terraform/execution-environment.yml"
            force: false # Don't overwrite if exists
            mode: '0644'
            content: |
              ---
              version: 3
              
              images:
                base_image:
                  name: registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8:latest
              
              dependencies:
                python:
                  - kubernetes>=12.0.0
                  - PyYAML>=5.1
                  - jmespath>=1.0.0
                  - python-terraform>=0.10.1
                system:
                  - which
                  - unzip
                  - wget
                  - curl
                galaxy:
                  collections:
                    - ansible.builtin
                    - community.general
              
              additional_build_steps:
                prepend_base:
                  - USER root
                  - COPY scripts/assemble /output/scripts/assemble
                  - RUN chmod +x /output/scripts/assemble
                prepend_base:
                  - USER root
                  - COPY scripts/assemble /output/scripts/assemble
                  - RUN chmod +x /output/scripts/assemble
          tags: [setup, files]
          
        - name: Create environment directories if they don't exist
          ansible.builtin.file:
            path: "{{ item }}"
            state: directory
            mode: '0755'
          loop:
            - "{{ playbook_dir }}/environments/rhel8-ee-minimal"
            - "{{ playbook_dir }}/environments/rhel9-ee-minimal"
            - "{{ playbook_dir }}/environments/rhel8-ee-minimal-terraform"
          tags: [setup, files]

        - name: Ensure environment directories exist
          ansible.builtin.file:
            path: "{{ playbook_dir }}/environments/{{ item }}"
            state: directory
            mode: '0755'
          loop:
            - "rhel8-ee-minimal"
            - "rhel9-ee-minimal"
            - "rhel8-ee-minimal-terraform"
          tags: [setup, files]

    - name: Create script directories
      ansible.builtin.file:
        path: "{{ playbook_dir }}/scripts"
        state: directory
        mode: '0755'
      tags: [monitoring, setup]
      
    - name: Create task files
      ansible.builtin.copy:
            dest: "{{ playbook_dir }}/scripts/start_monitor.sh"
            force: false
            mode: '0644'
            content: |
              {% raw %}
              #!/bin/bash

              # Save selected environments
              if [ "$1" != "" ]; then
                echo "$1" > /tmp/selected_envs
              fi

              # Kill any existing session to ensure clean slate
              tmux kill-session -t podman-monitor 2>/dev/null || true

              # Create initial status file with default message
              echo "NOTHING BUILDING YET" > /tmp/current_env

              # Create new session with dynamic dimensions
              tmux new-session -d -s podman-monitor

              # Split window into three panes with optimized sizes:
              tmux split-window -v -t podman-monitor:0.0 -p 85
              tmux split-window -v -t podman-monitor:0.1 -p 40

              # Top pane: ASCII art header and registry status
              tmux select-pane -t podman-monitor:0.0
              tmux send-keys -t podman-monitor:0.0 "clear; cat << 'EOF'
              ┌──────────────────────────────────────────────────────────────────────────┐
              │              ●●●●●●●                                                     │
              │             ●●●●●●●●●                                                    │
              │            ●●●●●●●●●●●                                                   │
              │    ╔══════●●●●●●═●●●●●●══════╗                                           │
              │    ║     ●●●●●●    ●●●●●● NSIBLE & PODMAN                                │
              │    ║    ●●●●●●      ●●●●●●    ║ EXECUTION ENVIRONMENT BUILD MONITOR      │
              │    ╚═══●●●●●●════════●●●●●●═══╝                                          │
              └──────────────────────────────────────────────────────────────────────────┘
              EOF
              " C-m

              tmux send-keys -t podman-monitor:0.0 "echo 'Selected environments:'" C-m
              tmux send-keys -t podman-monitor:0.0 "if [ -f /tmp/selected_envs ]; then cat /tmp/selected_envs; else echo 'None selected yet'; fi" C-m
              tmux send-keys -t podman-monitor:0.0 "echo ''" C-m
              tmux select-pane -t podman-monitor:0.2
              tmux send-keys -t podman-monitor:0.2 'watch -n .05 podman images' C-m

              echo "Monitor session started. Use 'tmux attach -t podman-monitor' to view."
              {% endraw %}
            tags: [setup, files]

    - name: Create terminal launch script
      ansible.builtin.copy:
        dest: "{{ scripts_dir }}/open_terminal.sh"  # Use the variable
        force: false
        mode: '0755'
        content: |
            {% raw %}
            #!/bin/bash
            
            IS_WSL="${1:-False}"
            
            if [ "$IS_WSL" = "True" ]; then
              echo "Trying to open Windows Terminal with tmux monitor session..."
              
              # Try multiple methods to launch Windows Terminal (simplest to most complex)
              
              # Method 1: Direct wt.exe approach
              if command -v wt.exe >/dev/null 2>&1; then
                wt.exe bash -c "tmux attach -t podman-monitor || echo No tmux session found" &
                exit_code=$?
                if [ $exit_code -eq 0 ]; then
                  echo "Launched with direct wt.exe method"
                  exit 0
                fi
              fi
              
              # Method 2: PowerShell approach
              if command -v powershell.exe >/dev/null 2>&1; then
                echo "Trying PowerShell approach..."
                powershell.exe -Command "Start-Process wt.exe -ArgumentList 'bash', '-c', 'tmux attach -t podman-monitor || echo No tmux session found'" &
                exit_code=$?
                if [ $exit_code -eq 0 ]; then
                  echo "Launched with PowerShell method"
                  exit 0
                fi
              fi
              
              # Method 3: CMD approach
              if command -v cmd.exe >/dev/null 2>&1; then
                echo "Trying CMD approach..."
                cmd.exe /c "start wt.exe bash -c \"tmux attach -t podman-monitor\"" &
                exit_code=$?
                if [ $exit_code -eq 0 ]; then  # FIXED: Added closing bracket
                  echo "Launched with CMD method"
                  exit 0
                fi
              fi
              
              echo "All Windows Terminal launch methods failed"
              echo "Please run manually: tmux attach -t podman-monitor"
            else
              # Standard Linux approaches
              if command -v x-terminal-emulator >/dev/null 2>&1; then
                x-terminal-emulator -e "tmux attach -t podman-monitor" &
              elif command -v gnome-terminal >/dev/null 2>&1; then
                gnome-terminal -- bash -c "tmux attach -t podman-monitor" &
              elif command -v xterm >/dev/null 2>&1; then
                xterm -e "tmux attach -t podman-monitor" &
              elif command -v konsole >/dev/null 2>&1; then
                konsole -e "tmux attach -t podman-monitor" &
              fi
            fi
            
            exit 0
            {% endraw %}
        tags: [monitoring]
      
    - name: Ensure terminal launch script is executable 
      ansible.builtin.file:
        path: "{{ playbook_dir }}/scripts/open_terminal.sh"
        mode: '0755'
      tags: [monitoring]
      
    # Fix for WSL environments - direct shell command to set executable
    - name: Make terminal launch script executable (WSL fix)
      ansible.builtin.shell: chmod +x {{ playbook_dir }}/scripts/open_terminal.sh
      args:
        executable: /bin/bash
      changed_when: true
      tags: [monitoring]

    - name: Debug WSL distributions (when in WSL)
      ansible.builtin.shell: |
        echo "WSL Distributions:"
        wsl.exe -l -v || echo "Cannot list distributions"
        echo "Current WSL version:"
        wsl.exe --version || echo "Cannot get WSL version"
        echo "Current distro: $(wsl.exe -l | grep -v "Windows Subsystem for Linux Distributions:" | head -1)"
      register: wsl_debug
      when: is_wsl_env | default(false)
      changed_when: false
      failed_when: false
      ignore_errors: true
      tags: [monitoring, debug]
      
    - name: Show WSL debug info
      ansible.builtin.debug:
        msg: "{{ wsl_debug.stdout_lines | default(['No WSL debug info available']) }}"
      when: wsl_debug is defined
      tags: [monitoring, debug]

    - name: Ensure monitoring script is executable
      ansible.builtin.file:
        path: "{{ playbook_dir }}/scripts/start_monitor.sh"
        mode: '0755'
      tags: [monitoring]
      
    - name: Make monitoring script executable (WSL compatibility)
      ansible.builtin.shell: chmod +x {{ playbook_dir }}/scripts/start_monitor.sh
      args:
        executable: /bin/bash
      changed_when: true
      tags: [monitoring]

    - name: Consolidated cleanup
      block:
        - name: Prune dangling images
          ansible.builtin.shell: |
            podman image prune -f
          register: prune_output
          changed_when: prune_output.stdout is search("deleted")
          
        - name: Remove images with <none> tag
          ansible.builtin.shell: |
            podman images | awk '$1=="<none>" {print $3}' | xargs -r podman rmi --force
          register: none_tags_output
          changed_when: none_tags_output.stdout != ""
          ignore_errors: true
      tags: [cleanup, pre_build, post_build]

    - name: Prompt for distribution selection
      ansible.builtin.pause:
        prompt: |
          Please select the distribution:
          Enter '8' for RHEL 8, '9' for RHEL 9, or 'all' for both
      register: user_input
      tags: [selection]
      
    - name: Set distribution_selection based on user input
      ansible.builtin.set_fact:
        distribution_selection: "{{ user_input.user_input }}"
      when: user_input.user_input is defined
      tags: [selection]

    - name: Set default values for build_rhel8 and build_rhel9
      ansible.builtin.set_fact:
        build_rhel8: false
        build_rhel9: false
      when: build_rhel8 is not defined or build_rhel9 is not defined
      tags: [selection]

    - name: Filter available environments based on distribution selection
      block:
        - name: Get all available environments
          ansible.builtin.find:
            paths: "environments"
            file_type: directory
          register: all_environments
          tags: [selection]

        - name: Process environments for filtering
          ansible.builtin.set_fact:
            rhel8_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel8') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            rhel9_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel9') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
            neutral_environments: "{{ all_environments.files | rejectattr('path', 'search', 'rhel[89]') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
          tags: [selection]

        - name: Set available environments based on distribution selection
          ansible.builtin.set_fact:
            available_environments: >-
              {{
                (distribution_selection == '8') | ternary(rhel8_environments, []) +
                (distribution_selection == '9') | ternary(rhel9_environments, []) +
                (distribution_selection == 'all') | ternary(rhel8_environments + rhel9_environments, []) +
                neutral_environments
              }}
          tags: [selection]
      tags: [selection]
          
    # Create a formatted list for display purposes
    - name: Create formatted environment list
      ansible.builtin.set_fact:
        formatted_env_list: |
          Available environments for selection:
          {% for env in available_environments %}
          {{ loop.index }}. {{ env | basename }}
          {% endfor %}
      tags: [selection]
      when: available_environments is defined and available_environments | length > 0

    # Force display the list with msg parameter
    - name: Display available environments (always show)
      ansible.builtin.debug:
        msg: "{{ formatted_env_list.split('\n') }}"
      tags: [selection]
      when: formatted_env_list is defined

    # Combine display and prompt in one step
    - name: Prompt for environment selection with display
      ansible.builtin.pause:
        prompt: |
          {{ formatted_env_list }}
          
          Select environments to build (comma-separated numbers, or 'all'):
          Example: 1,3,5 or all
      register: env_selection
      tags: [selection]
      when: available_environments is defined and available_environments | length > 0

    - name: Process environment selection
      block:
        - name: Set selected_environments when 'all' is chosen
          ansible.builtin.set_fact:
            selected_environments: "{{ available_environments }}"
          when: env_selection.user_input | lower == 'all'
          tags: [selection]
          
        - name: Set selected_environments based on numeric selection
          ansible.builtin.set_fact:
            selected_environments: "{{ env_selection.user_input.split(',') | map('trim') | map('int') | map('extract', available_environments, 0, item | int - 1) | list }}"
          when: env_selection.user_input | lower != 'all'
          tags: [selection]
          
        - name: Show selected environments
          ansible.builtin.debug:
            msg: |
              Selected environments to build:
              {% for env in selected_environments %}
              - {{ env | basename }}
              {% endfor %}
          tags: [selection]
          
        - name: Determine if running in WSL
          ansible.builtin.shell: |
            grep -q Microsoft /proc/version 2>/dev/null || grep -q WSL /proc/version 2>/dev/null
          register: is_wsl
          changed_when: false
          failed_when: false
          
        - name: Set WSL fact
          ansible.builtin.set_fact:
            is_wsl_env: "{{ is_wsl.rc == 0 }}"
            is_wsl_version: "{{ is_wsl.stdout }}"
                    
        - name: Show detailed monitoring connection instructions
          ansible.builtin.debug:
            msg: |
              ┌────────────────────────────────────────────────────────────┐
              │         MONITORING SESSION READY                           │
              ├────────────────────────────────────────────────────────────┤
              │                                                            │
              │  HOW TO VIEW THE BUILD MONITOR:                            │
              │                                                            │
              │  Option 1: Use tmux directly                               │
              │    1. Open a new terminal tab or window                    │
              │    2. Run this command:                                    │
              │       tmux attach -t podman-monitor                        │
              │                                                            │
              │  Option 2: Use helper script                               │
              │    1. Open a new terminal tab or window                    │
              │    2. Run: ~/tmux-connect.sh                               │
              │                                                            │
              │  Monitor Status: Active                                    │
              │                                                            │
              └────────────────────────────────────────────────────────────┘
          changed_when: false
          tags: [monitoring]
          
        - name: Start monitoring with selected environments
          ansible.builtin.shell: |
            ENVS=$(echo "{{ selected_environments | map('basename') | join('\n') }}")
            {{ playbook_dir }}/scripts/start_monitor.sh "$ENVS"
          changed_when: true
          tags: [monitoring]
          
      when: available_environments is defined and available_environments | length > 0 and env_selection.user_input is defined
      tags: [selection]

    - name: Create process_environment.yml dynamically in tasks/ folder
      ansible.builtin.file:
        path: "{{ playbook_dir }}/tasks"
        state: directory
        mode: '0755'
      tags: [setup, build]

    - name: Fix container builds by adding environment-specific assemble scripts
      block:
        - name: Create script directories for all environments
          ansible.builtin.file:
            path: "/tmp/ee-containers/context/environments/{{ item | basename }}/scripts"
            state: directory
            force: false
            mode: '0755'
          loop: "{{ selected_environments }}"
          
        - name: Create common assemble script for all environments
          ansible.builtin.template:
            src: "{{ playbook_dir }}/templates/assemble.sh.j2"
            dest: "/tmp/ee-containers/context/environments/{{ item | basename }}/scripts/assemble"
            force: false
            mode: '0755'
          loop: "{{ selected_environments }}"
          
        - name: Create execution environment directories if they don't exist
          ansible.builtin.file:
            path: "{{ playbook_dir }}/environments/{{ item | basename }}"
            state: directory
            mode: '0755'
          loop: "{{ selected_environments }}"
          
        - name: Create basic execution-environment.yml if missing
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/environments/{{ item | basename }}/execution-environment.yml"
            content: |
              ---
              version: 3
              
              images:
                base_image:
                  name: registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel{{ '9' if item | basename is search('rhel9') else '8' }}:latest
              
              dependencies:
                python:
                  - "kubernetes>=12.0.0"
                system:
                  - which
                galaxy:
                  collections: []
                
              additional_build_steps:
                prepend_base:
                  - USER root
                  - COPY scripts/assemble /output/scripts/assemble
                  - RUN chmod +x /output/scripts/assemble
            force: false  # Don't overwrite if exists
          loop: "{{ selected_environments }}"
          
        # Create required dependency files
        - name: Create requirements.yml for each environment
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/environments/{{ item | basename }}/requirements.yml"
            content: |
              ---
              collections:
                - ansible.builtin
                - community.general
            force: false  # Don't overwrite if exists
          loop: "{{ selected_environments }}"
          
        - name: Create requirements.txt for each environment
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/environments/{{ item | basename }}/requirements.txt"
            content: |
              kubernetes>=12.0.0
              PyYAML>=5.1
              jmespath>=1.0.0
              {% if 'terraform' in item | basename %}
              python-terraform>=0.10.1
              {% endif %}
              {% if 'servicenow' in item | basename %}
              pysnow>=0.8.0
              {% endif %}
            force: false  # Don't overwrite if exists
          loop: "{{ selected_environments }}"
          
        - name: Create bindep.txt for each environment
          ansible.builtin.copy:
            dest: "{{ playbook_dir }}/environments/{{ item | basename }}/bindep.txt"
            content: |
              which [platform:rpm]
              curl [platform:rpm]
              {% if 'terraform' in item | basename %}
              unzip [platform:rpm]
              wget [platform:rpm]
              {% endif %}
            force: false  # Don't overwrite if exists
          loop: "{{ selected_environments }}"
          
        - name: Copy all environment files to build context
          ansible.builtin.shell: |
            cp -r {{ playbook_dir }}/environments/{{ item | basename }}/* /tmp/ee-containers/context/environments/{{ item | basename }}/
          loop: "{{ selected_environments }}"
          changed_when: true
          
        - name: Create directories in /tmp/ee-containers/context
          ansible.builtin.file:
            path: "/tmp/ee-containers/context/environments/{{ item | basename }}"
            state: directory
            mode: '0755'
          loop: "{{ selected_environments }}"
          
        - name: Copy execution-environment.yml to build context
          ansible.builtin.copy:
            src: "{{ playbook_dir }}/environments/{{ item | basename }}/execution-environment.yml"
            dest: "/tmp/ee-containers/context/environments/{{ item | basename }}/execution-environment.yml"
            mode: '0644'
            remote_src: true
          loop: "{{ selected_environments }}"

    - name: Process each selected environment
      ansible.builtin.include_tasks: 
        file: "{{ playbook_dir }}/tasks/process_environment.yml"
      loop: "{{ selected_environments }}"
      loop_control:
        loop_var: ee_environment  # VERIFY this is ee_environment
        label: "{{ ee_environment | basename }}"
      register: build_results_all
      tags: [build]

    - name: Consolidated registry authentication
      block:
        - name: Load credentials if they exist
          ansible.builtin.include_vars:
            file: "{{ user_home }}/.ansible/vars/config"
          ignore_errors: true
          
        - name: Set credential status
          ansible.builtin.set_fact:
            has_valid_credentials: "{{ rh_username is defined and 
                                      rh_username | default('') != '' and 
                                      rh_password is defined and 
                                      rh_password | default('') != '' }}"
              
        - name: Login to registries with credentials
          ansible.builtin.shell: |
            podman login {{ item }} -u '{{ rh_username }}' -p '{{ rh_password }}' --tls-verify=false
          register: registry_login
          with_items: "{{ container_registries }}"
          changed_when: "'Login Succeeded' in registry_login.stdout"
          failed_when: false
          no_log: true
          when: has_valid_credentials | bool
          
        - name: Show registry authentication status
          ansible.builtin.debug:
            msg: "{{ has_valid_credentials | ternary('Registry authentication successful', 'Registry authentication skipped - no valid credentials') }}"
      tags: [registry, build]

    - name: Consolidated terminal launch
      block:
        - name: Ensure monitoring session exists
          ansible.builtin.shell: |
            if ! tmux has-session -t podman-monitor 2>/dev/null; then
              echo "Creating monitoring session..."
              {{ playbook_dir }}/scripts/start_monitor.sh
              sleep 2
            fi
          changed_when: true
          
        - name: Launch terminal window (only once)
          ansible.builtin.shell: |
            {{ playbook_dir }}/scripts/open_terminal.sh {{ is_wsl_env | default(false) }}
          register: terminal_launch
          changed_when: terminal_launch.rc == 0
          failed_when: false
          ignore_errors: true
      tags: [monitoring]

# Play 4: Summary and Status Report
- name: Summary and Status Report
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Generate build summary report
      ansible.builtin.debug:
        msg: |
          ┌──────────────────────────────────────────────────────────────────────────┐
          │                       EXECUTION ENVIRONMENT BUILD REPORT                 │
          ├──────────────────────────────────────────────────────────────────────────┤
          │ STATUS │ ENVIRONMENT                                                     │
          ├──────────────────────────────────────────────────────────────────────────┤
          {% for result in build_results | default([]) %}
          │ {{ '✅ PASS' if result.success else '❌ FAIL' }} │ {{ '%-65s' | format(result.image) }} │
          {% else %}
          │                       No environments were built                         │
          {% endfor %}
          └──────────────────────────────────────────────────────────────────────────┘
          
          {% set successful = build_results | default([]) | selectattr('success') | list %}
          {% set failed = build_results | default([]) | list %}
          
          Summary:
          - Total environments processed: {{ build_results | default([]) | length }}
          - Successfully built: {{ successful | length }}
          - Failed builds: {{ failed | length }}
          
          {% if failed %}
          Failed environments:
          {% for result in failed %}
          - {{ result.image }} (exit code: {{ result.output.rc }})
          {% endfor %}
          {% endif %}
      when: build_results is defined
      tags: [report]

    - name: Show no build results message
      ansible.builtin.debug:
        msg: "No build results available. Did you select any environments to build?"
      when: build_results is not defined or build_results | length == 0
      tags: [report]

# Play 5: Final cleanup
- name: Final cleanup
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Kill existing monitoring tmux session (if any)
      ansible.builtin.command: tmux has-session -t podman-monitor
      register: tmux_monitor_check
      changed_when: false
      failed_when: false
      tags: [cleanup, post_build]

    - name: Close existing monitoring tmux session
      ansible.builtin.shell: tmux kill-session -t podman-monitor
      when: tmux_monitor_check.rc == 0
      changed_when: true
      tags: [cleanup, post_build]
      
    - name: Show cleanup results
      ansible.builtin.debug:
        msg: "Cleanup completed: {{ 'No dangling images found' if prune_output.stdout == '' else prune_output.stdout }}"
      tags: [cleanup, post_build]
      
    - name: Final image pruning
      ansible.builtin.shell: podman image prune -f
      register: final_prune
      changed_when: final_prune.stdout is search("deleted")
      tags: [cleanup, post_build]

    - name: Clean up generated files
      block:
        - name: Ask for confirmation to clean up files
          ansible.builtin.pause:
            prompt: |
              Do you want to clean up all generated files and directories?
              This will remove everything except for:
              - README.md
              - environments/ directory (your EE definitions)
              - site.yml (this playbook)
              
              Enter 'yes' to clean up, or anything else to keep files
          register: cleanup_confirmation
          
        - name: Remove generated files and directories
          ansible.builtin.file:
            path: "{{ playbook_dir }}/{{ item }}"
            state: absent
          loop:
            - "templates"
            - "library"
            - "tasks"
            - "scripts"
            - "files"
            - "/tmp/ee-containers"
          when: cleanup_confirmation.user_input == "yes"
          
        - name: Show cleanup results
          ansible.builtin.debug:
            msg: "{{ 'Files cleaned up successfully.' if cleanup_confirmation.user_input == 'yes' else 'Files were kept.' }}"
      tags: [cleanup, post_build]
