---
# Ansible Automation Platform - Execution Environment Builder
# This playbook builds customized execution environments based on Red Hat AAP base images.
- name: Setup and store credentials
- hosts: localhost
  connection: local
  gather_facts: true
  environment:
  ANSIBLE_LOCALHOST_WARNING: "False"
  ANSIBLE_DEPRECATION_WARNINGS: "False"
  ANSIBLE_COMMAND_WARNINGS: "False"
  ANSIBLE_SYSTEM_WARNINGS: "False"

  vars:
  container_registries:
  - registry.redhat.io
- registry.access.redhat.com
- registry.connect.redhat.com

  required_images:
  - registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel8
- registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9
- registry.redhat.io/ansible-automation-platform-25/de-supported-rhel8
- registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9
- registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8
- registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9
- registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel8
- registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9

  protected_images:
  - "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9"
- "registry.redhat.io/ansible-automation-platform-25/de-minimal-rhel9:latest"
- "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9"
- "registry.redhat.io/ansible-automation-platform-25/de-supported-rhel9:latest"
- "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9"
- "registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest"
- "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9"
- "registry.redhat.io/ansible-automation-platform-25/ee-supported-rhel9:latest"
- "rhel9-de-minimal"
- "rhel9-de-minimal-cloudstrike"
- "rhel9-de-supported"
- "rhel9-ee-minimal"
- "rhel9-ee-minimal-cloud"
- "rhel9-ee-minimal-general"
- "rhel9-ee-minimal-vmware"
- "rhel9-ee-minimal-windows"
- "rhel9-ee-supported"
- "rhel9-ee-supported-vmware"

  dns_servers:
  - '8.8.8.8'
- '8.8.4.4'

  required_packages:
  - ansible-builder
- ansible-core
- autoconf
- automake
- bison
- gcc
- git
- make
- ncurses
- podman
- podman-docker
- python3-pip
- tmux
- xdg-utils
- yum-utils

  update_protected_list: true

  scripts_dir: "{{ playbook_dir }}/scripts"
  tasks_dir: "{{ playbook_dir }}/tasks"
  template_dir: "{{ playbook_dir }}/templates"
  environment_dir: "{{ playbook_dir }}/environments"
  terminal_script: "{{ scripts_dir }}/open_terminal.sh"
  monitor_script: "{{ scripts_dir }}/start_monitor.sh"
  process_env_task: "{{ tasks_dir }}/process_environment.yml"

  tasks:
  - name: Verify internet connectivity
  ansible.builtin.uri:
  url: https://google.com
  method: GET
  register: connectivity_check
  failed_when: connectivity_check.status != 200
  changed_when: false
  tags: [connectivity, validation, init]

    # Create static ansible.cfg before any template processing
- name: Create static ansible.cfg file for initial setup
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/ansible.cfg"
  mode: '0644'
  force: false # Don't overwrite if exists
  content: |
    [defaults]
    inventory = localhost,
    ansible_localhost_warning=false
    ansible_deprecation_warnings=false
    force_color = True

    [galaxy]
    server_list = validated, published, galaxy

    [galaxy_server.published]
  url=https://console.redhat.com/api/automation-hub/content/published/
  auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

    [galaxy_server.validated]
  url=https://console.redhat.com/api/automation-hub/content/validated/
  auth_url=https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token

    [galaxy_server.galaxy]
  url=https://galaxy.ansible.com/
  tags: [always, setup, init]

- name: Create collections requirements file
  ansible.builtin.copy:
  dest: "/tmp/requirements.yml"
  mode: '0644'
  content: |
---
collections:
  - name: ansible.utils
- name: ansible.posix
- name: community.general
- name: infra.aap_configuration
- name: infra.aap_utilities
  tags: [setup, always, collections, init]

- name: Create requirements.txt file
  ansible.builtin.copy:
  dest: "/tmp/requirements.txt"
  mode: '0644'
  content: |
    ansible-builder>=3.0.0
    ansible-core>=2.15.0,<2.16
    ansible-lint>=24.0.0
  tags: [setup, always, collections, init]

- name: Create inventory file
  ansible.builtin.copy:
  dest: "/tmp/inventory"
  force: false
  state: present
  mode: '0644'
  content: |
    [devnode]
    localhost ansible_connection=localhost
  tags: [always, setup, init]

- name: Force install community.general collection system-wide
  ansible.builtin.command:
  cmd: "sudo ansible-galaxy collection install community.general ansible.posix -p /usr/share/ansible/collections --force"
  register: galaxy_install
  changed_when: galaxy_install.rc == 0
  failed_when: galaxy_install.rc != 0
  tags: [setup, init]

- name: Verify community.general collection installation
  ansible.builtin.command:
  cmd: "ansible-galaxy collection list community.general"
  register: collection_verify
  failed_when: collection_verify.rc != 0
  tags: [setup, validation, init]

- name: Show installation path
  ansible.builtin.debug:
  msg: "Collection installed at: {{ collection_verify.stdout_lines | select('search', 'Path:') | first | default('Unknown location') }}"
  tags: [setup, init]

    # Improved user detection logic
- name: Get effective and real user info
  ansible.builtin.shell: |
    echo "EUID=$(id -u)"
    if [ -n "$SUDO_USER" ]; then
    echo "SUDO_USER=$SUDO_USER"
    echo "SUDO_UID=$(id -u $SUDO_USER)"
    echo "SUDO_HOME=$(eval echo ~$SUDO_USER)"
    else
    echo "SUDO_USER="
    echo "SUDO_UID="
    echo "SUDO_HOME="
    fi
    echo "USER=$(whoami)"
    echo "HOME=$HOME"
  register: user_info_output
  changed_when: false
  tags: [always, init]

- name: Parse user info
  ansible.builtin.set_fact:
  parsed_user_info: "{{ dict(user_info_output.stdout_lines | map('regex_replace', '^([^=]+)=(.*)$', '\\1:\\2') | map('split', ':') | list) }}"
  tags: [always, init]

- name: Set user facts
  ansible.builtin.set_fact:
  is_root: "{{ ansible_user_id == '0' }}"
  actual_user: "{{ ansible_user_id }}"
  user_home: "{{ ansible_env.HOME }}"
  tags: [always, init]

- name: Set current_user fact
  ansible.builtin.set_fact:
  current_user: "{{ actual_user }}"
  tags: [always, init]

- name: Debug user detection
  ansible.builtin.debug:
  msg: |
  User detection results:
  - Effective UID: {{ parsed_user_info.EUID }}
- Running as root: {{ is_root }}
- Original user: {{ actual_user }}
- User home: {{ user_home }}
  tags: [always, init]

    # Skip credential setup if running as root directly (not via sudo)
- name: Skip credential setup if running as root directly
  ansible.builtin.set_fact:
  skip_credential_setup: "{{ ansible_user_id == 'root' and lookup('env', 'SUDO_USER') == '' }}"
  tags: [always, creds]

- name: Skip credential setup for testing
  ansible.builtin.set_fact:
  skip_credential_setup: true
  tags: [always, creds]

- name: Show credential setup status
  ansible.builtin.debug:
  msg: "{{ skip_credential_setup | ternary('Running as direct root user - skipping credential setup', 'Setting up credentials for user ' + actual_user) }}"
  tags: [always, creds]

- name: Setup user credentials properly
  when: not skip_credential_setup
  block:
  - name: Ensure ansible vars directory exists in user's home
  ansible.builtin.file:
  path: "{{ user_home }}/.ansible/vars"
  state: directory
  mode: '0700'
  tags: [setup, credential_setup, creds]

- name: Check if credentials file exists
  ansible.builtin.stat:
  path: "{{ user_home }}/.ansible/vars/config"
  register: config_file
  tags: [always, creds]

- name: Fix permissions on credential directory if needed
  ansible.builtin.shell: |
    mkdir -p "{{ user_home }}/.ansible/vars"
    chmod 0700 "{{ user_home }}/.ansible"
    chmod 0700 "{{ user_home }}/.ansible/vars"
    touch "{{ user_home }}/.ansible/vars/config"
    chmod 0600 "{{ user_home }}/.ansible/vars/config"
  when: config_file is failed or not config_file.stat.exists
  changed_when: true
  tags: [always, creds]

- name: Create empty config file if it doesn't exist
  ansible.builtin.copy:
  dest: "{{ user_home }}/.ansible/vars/config"
  force: false
  content: |
---
# Ansible EE Builder Configuration - Last updated {{ ansible_date_time.iso8601 }}
rh_username: ''
rh_password: ''
automation_hub_token: ''
galaxy_token: ''
mode: '0600'
when: not config_file.stat.exists
tags: [setup, credential_setup, creds]

- name: Load stored credentials
  ansible.builtin.include_vars:
  file: "{{ user_home }}/.ansible/vars/config"
- name: stored_credentials
  tags: [always, creds]

- name: Check if config file has required variables
  ansible.builtin.set_fact:
  has_rh_username: "{{ stored_credentials.rh_username is defined and stored_credentials.rh_username != '' }}"
  has_rh_password: "{{ stored_credentials.rh_password is defined and stored_credentials.rh_password != '' }}"
  has_automation_hub_token: "{{ stored_credentials.automation_hub_token is defined }}"
  has_galaxy_token: "{{ stored_credentials.galaxy_token is defined }}"
  tags: [always, creds]

- name: Collect Red Hat CDN username if missing
  ansible.builtin.pause:
  prompt: "Enter your Red Hat CDN username"
  echo: true
  register: rh_username_input
  when: not has_rh_username
  tags: [creds]

- name: Collect Red Hat CDN password if missing
  ansible.builtin.pause:
  prompt: "Enter your Red Hat CDN password"
  echo: false
  register: rh_password_input
  when: not has_rh_password
  no_log: false
  tags: [creds]

- name: Collect Automation Hub token if missing
  ansible.builtin.pause:
  prompt: "Enter your Automation Hub token (or press enter to skip)"
  echo: false
  register: automation_hub_token_input
  when: not has_automation_hub_token
  no_log: false
  tags: [creds]

- name: Collect Galaxy token if missing
  ansible.builtin.pause:
  prompt: "Enter your Galaxy token (or press enter to skip)"
  echo: false
  register: galaxy_token_input
  when: not has_galaxy_token
  no_log: false
  tags: [creds]

- name: Update credentials while preserving existing values
  ansible.builtin.set_fact:
  rh_username: "{{ rh_username_input.user_input if (rh_username_input is defined and rh_username_input.user_input is defined) else stored_credentials.rh_username | default('') }}"
  rh_password: "{{ rh_password_input.user_input if (rh_password_input is defined and rh_password_input.user_input is defined) else stored_credentials.rh_password | default('') }}"
  automation_hub_token: "{{ automation_hub_token_input.user_input if (automation_hub_token_input is defined and automation_hub_token_input.user_input is defined) else stored_credentials.automation_hub_token | default('') }}"
  galaxy_token: "{{ galaxy_token_input.user_input if (galaxy_token_input is defined and galaxy_token_input.user_input is defined) else stored_credentials.galaxy_token | default('') }}"
  no_log: false
  tags: [creds]

- name: Save updated credentials to file (preserving existing values)
  block:
  - name: Ensure ansible vars directory exists with correct permissions
  ansible.builtin.file:
  path: "{{ user_home }}/.ansible/vars"
  state: directory
  mode: '0700'
  owner: "{{ actual_user }}"
  become: "{{ is_root }}"

- name: Create credentials file with proper permissions
  ansible.builtin.shell: |
    cat > "{{ user_home }}/.ansible/vars/config" << 'EOL'
---
# Ansible EE Builder Configuration - Last updated {{ ansible_date_time.iso8601 }}
rh_username: '{{ rh_username }}'
rh_password: '{{ rh_password }}'
automation_hub_token: '{{ automation_hub_token }}'
galaxy_token: '{{ galaxy_token }}'
EOL
chmod 0600 "{{ user_home }}/.ansible/vars/config"
args:
executable: /bin/bash
changed_when: true
rescue:
  - name: Handle credentials file creation failure
  ansible.builtin.debug:
  msg: "Failed to save credentials file. Using fallback method."
  tags: [creds]

- name: Show run mode
  ansible.builtin.debug:
  msg: |
    ┌────────────────────────────────────────────────────────────────────┐
    │ RUN MODE INFORMATION │
    ├────────────────────────────────────────────────────────────────────┤
  │ {{ "FIRST RUN DETECTED: Running full setup" if first_run | default(false) else "SUBSEQUENT RUN: Using stored configuration" }} │
    │ │
  │ User: {{ actual_user | default('Unknown') }} │
  │ Credentials: {{ "New" if first_run | default(false) else "Loaded from file" }} │
    └────────────────────────────────────────────────────────────────────┘
  tags: [always, creds]

    # Use sudo_user's home directory for config in the main play
- name: Set config path for main play
  ansible.builtin.set_fact:
  config_path: "{{ user_home }}/.ansible/vars/config"
  tags: [always, creds]

- name: Check if credentials template file exists
  ansible.builtin.stat:
  path: "{{ playbook_dir }}/templates/config.j2"
  register: template_file
  tags: [setup, creds, init]

- name: Create credentials template file
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/templates/config.j2"
  force: false
  mode: '0600'
  content: |
---
# Ansible EE Builder Configuration - Last updated {{ ansible_date_time.iso8601 }}
rh_username: '{{ rh_username }}'
rh_password: '{{ rh_password }}'
automation_hub_token: '{{ automation_hub_token }}'
galaxy_token: '{{ galaxy_token }}'
when: not template_file.stat.exists
tags: [setup, creds, init]

# Play 2: Display title and introduction
- name: Display title screen
- hosts: localhost
  connection: local
  gather_facts: false
  environment:
  ANSIBLE_LOCALHOST_WARNING: "False"
  ANSIBLE_DEPRECATION_WARNINGS: "False"
  ANSIBLE_COMMAND_WARNINGS: "False"
  ANSIBLE_SYSTEM_WARNINGS: "False"
  tasks:
  - name: Show ascii title
  ansible.builtin.debug:
  msg: |
    ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
  │ ..:-=@@@@=-:.. │
    │ .*%@@@@@@@@@@@@%*. │
  │ .:@@@@@@@@@@@@@@@@@@@@:. │
    │ .*@@@@@@@@@@*-@@@@@@@@@@*. │
    │ .@@@@@@@@@@@*. =@@@@@@@@@@@. │
    │ .%@@@@@@@@@@@ .@ +@@@@@@@@@@%. │
    │ -%@@@@@@@@@@..@%-.*@@@@@@@@@%- │
  │ "A Streamlined Approach to Building Ansible Execution Environments" .+@@@@@@@@@@= =@@@.:@@@@@@@@@@+. │
  │ .+@@@@@@@@@@ ..:+@%.-@@@@@@@@@+. │
    │ .=@@@@@@@@@ .@@+. *+.-@@@@@@@%= │
  │ .%@@@@@@@:.*@@@@%. .+@@@@@@%. │
  │ .@@@@@@= =@@@@@@@%=.:%@@@@@. │
  │ :%@@@@@@@@@@@@@@@@@@@@@@%: │
    │ .*@@@@@@@@@@@@@@@@@@@@*. │
    │ .+@@@@@@@@@@@@@@@@+.. │
    │ ..+*%@@@@@@%*+.. │
    └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
  tags: [always, init]

- name: Title screen
  ansible.builtin.pause:
  seconds: 3
  tags: [always, init]

  # Play 3: Environment Selection and Build Process
- name: Environment Selection and Build Process
- hosts: localhost
  connection: local
  gather_facts: false
  vars:
  scripts_dir: "{{ playbook_dir }}/scripts"
  tasks_dir: "{{ playbook_dir }}/tasks"
  template_dir: "{{ playbook_dir }}/templates"
  environment_dir: "{{ playbook_dir }}/environments"
  terminal_script: "{{ scripts_dir }}/open_terminal.sh"
  monitor_script: "{{ scripts_dir }}/start_monitor.sh"
  process_env_task: "{{ tasks_dir }}/process_environment.yml"
  tasks:
    # Add WSL detection at the beginning
- name: Determine if running in WSL (global)
  ansible.builtin.shell: |
    grep -q Microsoft /proc/version 2>/dev/null || grep -q WSL /proc/version 2>/dev/null
  register: is_wsl_global
  changed_when: false
  failed_when: false
  tags: [always]

- name: Set global WSL fact
  ansible.builtin.set_fact:
  is_wsl_env: "{{ is_wsl_global.rc == 0 }}"
  tags: [always]

- name: Create all required directories
  ansible.builtin.file:
  path: "{{ item }}"
  state: directory
  mode: '0755'
  loop:
    # Playbook structure directories
- "{{ playbook_dir }}/scripts"
- "{{ playbook_dir }}/library"
- "{{ playbook_dir }}/tasks"
- "{{ playbook_dir }}/templates"
- "{{ playbook_dir }}/files"

    # Runtime directories
- "/tmp/ee-containers"
- "/tmp/ee-containers/context"
- "/tmp/ee-containers/context/environments"
- "/tmp/ee-containers/_build"

    # Ansible configuration directories
- "~/.ansible"
- "~/.ansible/vars"
- "~/.ansible/tmp"
  tags: [setup, init, pre_reqs]

- name: Create all required project files
  block:
  - name: Create start_monitor.sh script
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/scripts/start_monitor.sh"
  force: false
  mode: '0755'
  content: |
    #!/bin/bash
    {% raw %}
    # Kill any existing session to ensure clean slate
    tmux kill-session -t podman-monitor 2>/dev/null || true

    # Create initial status file with default message
    echo "NOTHING BUILDING YET" > /tmp/current_env

    # Create new session with dynamic dimensions
    tmux new-session -d -s podman-monitor

  # Split window into three panes with optimized sizes:
  tmux split-window -v -t podman-monitor:0.0 -p 85
  tmux split-window -v -t podman-monitor:0.1 -p 5

  # Top pane: ASCII art header
  tmux select-pane -t podman-monitor:0.0
  tmux send-keys -t podman-monitor:0.0 "clear; cat << 'EOF'
    ┌──────────────────────────────────────────────────────────────────────────┐
    │ ●●●●●●● │
    │ ●●●●●●●●● │
    │ ●●●●●●●●●●● │
    │ ╔══════●●●●●●═●●●●●●══════╗ │
    │ ║ ●●●●●● ●●●●●● NSIBLE & PODMAN │
    │ ║ ●●●●●● ●●●●●● ║ EXECUTION ENVIRONMENT BUILD MONITOR │
    │ ╚═══●●●●●●════════●●●●●●═══╝ │
    └──────────────────────────────────────────────────────────────────────────┘
    EOF
    " C-m

  # Middle pane: Single-line status display
  tmux select-pane -t podman-monitor:0.1
  tmux send-keys -t podman-monitor:0.1 'while true; do
    clear
    BUILDING_FILE=/tmp/current_env
    if [ -f "$BUILDING_FILE" ]; then
    BUILDING_ENV=$(cat "$BUILDING_FILE")

    OUTPUT="$BUILDING_ENV"

    if [[ "$BUILDING_ENV" != "SKIPPED"* &&
    "$BUILDING_ENV" != "COMPLETED"* &&
    "$BUILDING_ENV" != "NOTHING BUILDING YET" &&
    "$BUILDING_ENV" != "FAILED"* ]]; then
    SPINNER_CHARS=("|" "/" "-" "\\")
    SPINNER_INDEX=$(( (SECONDS / 1) % 4 ))
    SPINNER=${SPINNER_CHARS[$SPINNER_INDEX]}
  OUTPUT="⏳ Building: $BUILDING_ENV ${SPINNER}"
    elif [[ "$BUILDING_ENV" == "FAILED"* ]]; then
    OUTPUT="[FAIL] $BUILDING_ENV"
    elif [[ "$BUILDING_ENV" == "COMPLETED"* ]]; then
    OUTPUT="[PASS] $BUILDING_ENV"
    elif [[ "$BUILDING_ENV" == "NOTHING BUILDING YET" ]]; then
    OUTPUT=" $BUILDING_ENV"
    fi

    COLS=$(tput cols)
    printf "%*s\n" $(( (${#OUTPUT} + COLS) / 2 )) "$OUTPUT"
    else
    COLS=$(tput cols)
    MSG="NOTHING BUILDING YET"
    printf "%*s\n" $(( (${#MSG} + COLS) / 2 )) " $MSG"
    fi
    sleep 0.5
    done' C-m

  # Bottom pane: Use faster refresh for podman images
  tmux select-pane -t podman-monitor:0.2
  tmux send-keys -t podman-monitor:0.2 'watch -n .05 podman images' C-m

    echo "Monitor session started. Use 'tmux attach -t podman-monitor' to view."
    {% endraw %}
  tags: [setup, files, monitoring]

- name: Create templates directory and files
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/templates/assemble.sh.j2"
  force: false
  mode: '0755'
  content: |
    #!/bin/bash
    set -ex

    {% raw %}
    echo "Running custom assemble script for {{ item | basename }}"

    # Use proper package manager based on availability
    if command -v microdnf &> /dev/null; then
    PKG_MGR="microdnf"
    elif command -v dnf &> /dev/null; then
    PKG_MGR="dnf"
    else
    PKG_MGR="yum"
    fi

  echo "Using package manager: $PKG_MGR"

    # Install any required system packages
    if [ -f /tmp/src/bindep.txt]; then
    echo "Installing packages from bindep.txt"
    $PKG_MGR install -y $(cat /tmp/src/bindep.txt | grep -v "^#" | xargs)
    fi

    # Install Python requirements
    if [ -f /tmp/src/requirements.txt]; then
    echo "Installing Python requirements"
    {% endraw %}
    {% raw %}{% if "terraform" in (item | basename) %}{% endraw %}
    # Fix terraform requirements
  echo "Original requirements.txt:"
    cat /tmp/src/requirements.txt
    grep -v -- "--exclude" /tmp/src/requirements.txt > /tmp/requirements.clean.txt
  echo "Cleaned requirements.txt:"
    cat /tmp/requirements.clean.txt
    pip3 install --no-cache-dir -r /tmp/requirements.clean.txt
    {% raw %}{% else %}{% endraw %}
    pip3 install --no-cache-dir -r /tmp/src/requirements.txt
    {% raw %}{% endif %}{% endraw %}
    fi

    # Add environment-specific customizations
    {% raw %}{% if "terraform" in (item | basename) %}{% endraw %}
    echo "Adding Terraform-specific configuration"
    $PKG_MGR install -y unzip curl wget which
    TERRAFORM_VERSION="1.5.7"
    cd /tmp
  curl -LO "https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip"
    unzip -o "terraform_${TERRAFORM_VERSION}_linux_amd64.zip"
    mv terraform /usr/local/bin/
    chmod +x /usr/local/bin/terraform
    pip3 install --no-cache-dir terraform-provider python-terraform
    {% raw %}{% endif %}{% endraw %}

    {% raw %}{% if "servicenow" in (item | basename) %}{% endraw %}
    echo "Adding ServiceNow-specific configuration"
    pip3 install --no-cache-dir pysnow servicenow_client
    {% raw %}{% endif %}{% endraw %}

    echo "Custom assemble script completed successfully"
    exit 0
  tags: [setup, files]

- name: Create task files
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/tasks/process_environment.yml"
  force: false
  mode: '0644'
  content: |
    {% raw %}
---
# This file is generated dynamically by site.yml
# Tasks for processing individual execution environments

- name: Get environment name
  ansible.builtin.set_fact:
  env_name: "{{ ee_environment | basename }}" # Use ee_environment, not environment

- name: Update current build status for monitoring
  ansible.builtin.copy:
  dest: /tmp/current_env
  content: "Building: {{ env_name }}"
  mode: '0644'
  changed_when: true

- name: Extract base image information
  ansible.builtin.shell: |
  grep -A 3 "base_image:" "{{ ee_environment }}/execution-environment.yml" | grep "name:" | awk -F"'" '{print $2}' | tr -d "'" # Changed from environment to ee_environment
  register: base_image_info
  changed_when: false

- name: Login to registry for this image
  ansible.builtin.shell: |
    REGISTRY=$(echo "{{ base_image_info.stdout }}" | cut -d'/' -f1)
    if [ ! -z "$REGISTRY" ]; then
  echo "Logging into registry: $REGISTRY"
    podman login $REGISTRY -u '{{ rh_username | default("") }}' -p '{{ rh_password | default("") }}' --tls-verify=false
    fi
  register: registry_login
  no_log: true
  failed_when: false
  when: base_image_info.stdout | length > 0

- name: Pull the base image directly
  ansible.builtin.shell: |
    podman pull --tls-verify=false "{{ base_image_info.stdout }}"
  register: image_pull
  changed_when: image_pull.rc == 0
  failed_when: false

- name: Create execution environment directory
  ansible.builtin.file:
  path: "/tmp/ee-containers/context/environments/{{ env_name }}"
  state: directory
  mode: '0755'

- name: Create scripts directory for execution environment
  ansible.builtin.file:
  path: "/tmp/ee-containers/context/environments/{{ env_name }}/scripts"
  state: directory
  mode: '0755'

- name: Ensure assemble script content
  ansible.builtin.template:
  src: "{{ playbook_dir }}/templates/assemble.sh.j2"
  dest: "/tmp/ee-containers/context/environments/{{ env_name }}/scripts/assemble"
  mode: '0755'
  vars:
  item: "{{ ee_environment }}" # ADD THIS LINE to pass ee_environment as item to the template

- name: Copy environment files to build context
  ansible.builtin.shell: |
    cp -r {{ ee_environment }}/* /tmp/ee-containers/context/environments/{{ env_name }}/ # Changed from environment to ee_environment
  changed_when: true

- name: Build execution environment image
  ansible.builtin.shell: |
    cd /tmp/ee-containers/context/environments/{{ env_name }} && \
    ansible-builder build \
    --tag {{ env_name }} \
    --container-runtime podman \
    --verbosity 2 \
    --prune-images \
    --context . \
    -f execution-environment.yml
  register: build_result
  failed_when: build_result.rc != 0
  changed_when: build_result.rc == 0

- name: Record build result
  ansible.builtin.set_fact:
  build_status: "{{ build_result.rc == 0 }}"
  build_output: "{{ build_result }}"
  changed_when: false

- name: Update status file with completion
  ansible.builtin.copy:
  dest: /tmp/current_env
  content: "COMPLETED: {{ env_name }}"
  mode: '0644'
  changed_when: true
  when: build_status

- name: Update status file with failure
  ansible.builtin.copy:
  dest: /tmp/current_env
  content: "FAILED: {{ env_name }}"
  mode: '0644'
  changed_when: true
  when: not build_status

    {% endraw %}
  tags: [setup, files]

- name: Create library directory and custom module
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/library/podman_image_info.py"
  force: false
  mode: '0755'
  content: |
    #!/usr/bin/python

  # Copyright: (c) 2023, Your Name <your.email@example.com>
  # GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

    from __future__ import (absolute_import, division, print_function)
    __metaclass__ = type

    DOCUMENTATION = r'''
---
module: podman_image_info
short_description: Gather information about Podman images
description:
  - Gather information about Podman images.
- Lists images and their attributes.
options:
  - name:
  description:
  - Filter by image name.
  type: str
  required: false
  tag:
  description:
  - Filter by image tag.
  type: str
  required: false
  author:
  - "Your Name (@yourGitHubHandle)"
    '''

    EXAMPLES = r'''
- name: Get info about all images
  podman_image_info:
  register: image_info

- name: Get info about a specific image
  podman_image_info:
  - name: registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8
  register: specific_image_info
    '''

    RETURN = r'''
  images:
  description: List of image dictionaries
  returned: always
  type: list
  elements: dict
  contains:
  id:
  description: Image ID
  type: str
  sample: "sha256:f9a9f253f6798722d9e692c2b1429aa1"
  names:
  description: Image names and tags
  type: list
  sample: ["registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8:latest"]
  created:
  description: When the image was created
  type: str
  sample: "2023-04-20T10:15:30Z"
  size:
  description: Image size in bytes
  type: int
  sample: 358974135
    '''

    import json
    import re
    import subprocess

    from ansible.module_utils.basic import AnsibleModule

  def run_command(module, command):
    """Run a Podman command and return the output."""
  try:
    result = subprocess.run(
    command,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    check=False,
    universal_newlines=True
    )
  if result.returncode != 0:
    module.fail_json(
    msg="Failed to execute command",
    command=command,
    stdout=result.stdout,
    stderr=result.stderr,
    rc=result.returncode
    )
    return result.stdout
  except Exception as e:
  module.fail_json(msg=f"Command execution error: {e}", command=command)

  def get_image_info(module, name=None, tag=None):
    """Get image information using podman images."""
    command = ["podman", "images", "--format", "json"]

  if name:
    command.append(name)
  if tag:
  command[-1] = f"{name}:{tag}"

    output = run_command(module, command)

  try:
    return json.loads(output)
  except json.JSONDecodeError:
    module.fail_json(msg="Failed to parse podman images output", output=output)

  def main():
    """Main module function."""
    module_args = {
  'name': {'type': 'str', 'required': False},
  'tag': {'type': 'str', 'required': False}
    }

  result = {'changed': False}
    module = AnsibleModule(argument_spec=module_args, supports_check_mode=True)

    # In check mode, return empty list
  if module.check_mode:
    result['images'] = []
    module.exit_json(**result)

    name = module.params['name']
    tag = module.params['tag']

    result['images'] = get_image_info(module, name, tag)
    module.exit_json(**result)

  if __name__ == '__main__':
    main()
  tags: [setup, files]

- name: Create files directory and content
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/files/build-banner.txt"
  force: false
  mode: '0644'
  content: |
    ┌──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
  │ ..:-=@@@@=-:.. │
    │ .*%@@@@@@@@@@@@%*. │
  │ .:@@@@@@@@@@@@@@@@@@@@:. │
    │ .*@@@@@@@@@@*-@@@@@@@@@@*. │
    │ .@@@@@@@@@@@*. =@@@@@@@@@@@. │
    │ .%@@@@@@@@@@@ .@ +@@@@@@@@@@%. │
    │ -%@@@@@@@@@@..@%-.*@@@@@@@@@%- │
  │ "A Streamlined Approach to Building Ansible Execution Environments" .+@@@@@@@@@@= =@@@.:@@@@@@@@@@+. │
  │ .+@@@@@@@@@@ ..:+@%.-@@@@@@@@@+. │
    │ .=@@@@@@@@@ .@@+. *+.-@@@@@@@%= │
  │ .%@@@@@@@:.*@@@@%. .+@@@@@@%. │
  │ .@@@@@@= =@@@@@@@%=.:%@@@@@. │
  │ :%@@@@@@@@@@@@@@@@@@@@@@%: │
    │ .*@@@@@@@@@@@@@@@@@@@@*. │
    │ .+@@@@@@@@@@@@@@@@+.. │
    │ ..+*%@@@@@@%*+.. │
    └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
  tags: [setup, files]

- name: Create sample environment files (if directory is empty)
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/environments/rhel8-ee-minimal/execution-environment.yml"
  force: false # Don't overwrite if exists
  mode: '0644'
  content: |
---
version: 3

images:
base_image:
  - name: registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8:latest

  dependencies:
  python:
  - kubernetes>=12.0.0
- PyYAML>=5.1
- jmespath>=1.0.0
  system:
  - which
  galaxy:
  collections:
  - ansible.builtin
- community.general

  additional_build_steps:
  prepend_base:
  - USER root
- COPY scripts/assemble /output/scripts/assemble
- RUN chmod +x /output/scripts/assemble
  tags: [setup, files]

- name: Create rhel9 sample environment
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/environments/rhel9-ee-minimal/execution-environment.yml"
  force: false
  content: |
---
version: 3

images:
base_image:
  - name: registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel9:latest

  dependencies:
  python:
  - kubernetes>=12.0.0
- PyYAML>=5.1
- jmespath>=1.0.0
  system:
  - which
  galaxy:
  collections:
  - ansible.builtin
- community.general

  additional_build_steps:
  prepend_base:
  - USER root
- COPY scripts/assemble /output/scripts/assemble
- RUN chmod +x /output/scripts/assemble
  tags: [setup, files]

- name: Create terraform sample environment
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/environments/rhel8-ee-minimal-terraform/execution-environment.yml"
  force: false # Don't overwrite if exists
  mode: '0644'
  content: |
---
version: 3

images:
base_image:
  - name: registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel8:latest

  dependencies:
  python:
  - kubernetes>=12.0.0
- PyYAML>=5.1
- jmespath>=1.0.0
- python-terraform>=0.10.1
  system:
  - which
- unzip
- wget
- curl
  galaxy:
  collections:
  - ansible.builtin
- community.general

  additional_build_steps:
  prepend_base:
  - USER root
- COPY scripts/assemble /output/scripts/assemble
- RUN chmod +x /output/scripts/assemble
  prepend_base:
  - USER root
- COPY scripts/assemble /output/scripts/assemble
- RUN chmod +x /output/scripts/assemble
  tags: [setup, files]

- name: Create environment directories if they don't exist
  ansible.builtin.file:
  path: "{{ item }}"
  state: directory
  mode: '0755'
  loop:
  - "{{ playbook_dir }}/environments/rhel8-ee-minimal"
- "{{ playbook_dir }}/environments/rhel9-ee-minimal"
- "{{ playbook_dir }}/environments/rhel8-ee-minimal-terraform"
  tags: [setup, files]

- name: Ensure environment directories exist
  ansible.builtin.file:
  path: "{{ playbook_dir }}/environments/{{ item }}"
  state: directory
  mode: '0755'
  loop:
  - "rhel8-ee-minimal"
- "rhel9-ee-minimal"
- "rhel8-ee-minimal-terraform"
  tags: [setup, files]

- name: Create script directories
  ansible.builtin.file:
  path: "{{ playbook_dir }}/scripts"
  state: directory
  mode: '0755'
  tags: [monitoring, setup]

- name: Create task files
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/scripts/start_monitor.sh"
  force: false
  mode: '0644'
  content: |
    {% raw %}
    #!/bin/bash

    # Save selected environments
    if [ "$1" != "" ]; then
    echo "$1" > /tmp/selected_envs
    fi

    # Kill any existing session to ensure clean slate
    tmux kill-session -t podman-monitor 2>/dev/null || true

    # Create initial status file with default message
    echo "NOTHING BUILDING YET" > /tmp/current_env

    # Create new session with dynamic dimensions
    tmux new-session -d -s podman-monitor

  # Split window into three panes with optimized sizes:
  tmux split-window -v -t podman-monitor:0.0 -p 85
  tmux split-window -v -t podman-monitor:0.1 -p 40

  # Top pane: ASCII art header and registry status
  tmux select-pane -t podman-monitor:0.0
  tmux send-keys -t podman-monitor:0.0 "clear; cat << 'EOF'
    ┌──────────────────────────────────────────────────────────────────────────┐
    │ ●●●●●●● │
    │ ●●●●●●●●● │
    │ ●●●●●●●●●●● │
    │ ╔══════●●●●●●═●●●●●●══════╗ │
    │ ║ ●●●●●● ●●●●●● NSIBLE & PODMAN │
    │ ║ ●●●●●● ●●●●●● ║ EXECUTION ENVIRONMENT BUILD MONITOR │
    │ ╚═══●●●●●●════════●●●●●●═══╝ │
    └──────────────────────────────────────────────────────────────────────────┘
    EOF
    " C-m

  tmux send-keys -t podman-monitor:0.0 "echo 'Selected environments:'" C-m
  tmux send-keys -t podman-monitor:0.0 "if [ -f /tmp/selected_envs ]; then cat /tmp/selected_envs; else echo 'None selected yet'; fi" C-m
  tmux send-keys -t podman-monitor:0.0 "echo ''" C-m
  tmux select-pane -t podman-monitor:0.2
  tmux send-keys -t podman-monitor:0.2 'watch -n .05 podman images' C-m

    echo "Monitor session started. Use 'tmux attach -t podman-monitor' to view."
    {% endraw %}
  tags: [setup, files]

- name: Create terminal launch script
  ansible.builtin.copy:
  dest: "{{ scripts_dir }}/open_terminal.sh" # Use the variable
  force: false
  mode: '0755'
  content: |
    {% raw %}
    #!/bin/bash

  IS_WSL="${1:-False}"

    if [ "$IS_WSL" = "True" ]; then
    echo "Trying to open Windows Terminal with tmux monitor session..."

    # Try multiple methods to launch Windows Terminal (simplest to most complex)

  # Method 1: Direct wt.exe approach
    if command -v wt.exe >/dev/null 2>&1; then
    wt.exe bash -c "tmux attach -t podman-monitor || echo No tmux session found" &
    exit_code=$?
    if [ $exit_code -eq 0 ]; then
    echo "Launched with direct wt.exe method"
    exit 0
    fi
    fi

  # Method 2: PowerShell approach
    if command -v powershell.exe >/dev/null 2>&1; then
    echo "Trying PowerShell approach..."
    powershell.exe -Command "Start-Process wt.exe -ArgumentList 'bash', '-c', 'tmux attach -t podman-monitor || echo No tmux session found'" &
    exit_code=$?
    if [ $exit_code -eq 0 ]; then
    echo "Launched with PowerShell method"
    exit 0
    fi
    fi

  # Method 3: CMD approach
    if command -v cmd.exe >/dev/null 2>&1; then
    echo "Trying CMD approach..."
    cmd.exe /c "start wt.exe bash -c \"tmux attach -t podman-monitor\"" &
    exit_code=$?
  if [ $exit_code -eq 0 ]; then # FIXED: Added closing bracket
    echo "Launched with CMD method"
    exit 0
    fi
    fi

    echo "All Windows Terminal launch methods failed"
  echo "Please run manually: tmux attach -t podman-monitor"
    else
    # Standard Linux approaches
    if command -v x-terminal-emulator >/dev/null 2>&1; then
    x-terminal-emulator -e "tmux attach -t podman-monitor" &
    elif command -v gnome-terminal >/dev/null 2>&1; then
    gnome-terminal -- bash -c "tmux attach -t podman-monitor" &
    elif command -v xterm >/dev/null 2>&1; then
    xterm -e "tmux attach -t podman-monitor" &
    elif command -v konsole >/dev/null 2>&1; then
    konsole -e "tmux attach -t podman-monitor" &
    fi
    fi

    exit 0
    {% endraw %}
  tags: [monitoring]

- name: Ensure terminal launch script is executable
  ansible.builtin.file:
  path: "{{ playbook_dir }}/scripts/open_terminal.sh"
  mode: '0755'
  tags: [monitoring]

    # Fix for WSL environments - direct shell command to set executable
- name: Make terminal launch script executable (WSL fix)
  ansible.builtin.shell: chmod +x {{ playbook_dir }}/scripts/open_terminal.sh
  args:
  executable: /bin/bash
  changed_when: true
  tags: [monitoring]

- name: Debug WSL distributions (when in WSL)
  ansible.builtin.shell: |
  echo "WSL Distributions:"
    wsl.exe -l -v || echo "Cannot list distributions"
  echo "Current WSL version:"
    wsl.exe --version || echo "Cannot get WSL version"
  echo "Current distro: $(wsl.exe -l | grep -v "Windows Subsystem for Linux Distributions:" | head -1)"
  register: wsl_debug
  when: is_wsl_env | default(false)
  changed_when: false
  failed_when: false
  ignore_errors: true
  tags: [monitoring, debug]

- name: Show WSL debug info
  ansible.builtin.debug:
  msg: "{{ wsl_debug.stdout_lines | default(['No WSL debug info available']) }}"
  when: wsl_debug is defined
  tags: [monitoring, debug]

- name: Ensure monitoring script is executable
  ansible.builtin.file:
  path: "{{ playbook_dir }}/scripts/start_monitor.sh"
  mode: '0755'
  tags: [monitoring]

- name: Make monitoring script executable (WSL compatibility)
  ansible.builtin.shell: chmod +x {{ playbook_dir }}/scripts/start_monitor.sh
  args:
  executable: /bin/bash
  changed_when: true
  tags: [monitoring]

- name: Consolidated cleanup
  block:
  - name: Prune dangling images
  ansible.builtin.shell: |
    podman image prune -f
  register: prune_output
  changed_when: prune_output.stdout is search("deleted")

- name: Remove images with <none> tag
  ansible.builtin.shell: |
    podman images | awk '$1=="<none>" {print $3}' | xargs -r podman rmi --force
  register: none_tags_output
  changed_when: none_tags_output.stdout != ""
  ignore_errors: true
  tags: [cleanup, pre_build, post_build]

- name: Prompt for distribution selection
  ansible.builtin.pause:
  prompt: |
  Please select the distribution:
    Enter '8' for RHEL 8, '9' for RHEL 9, or 'all' for both
  register: user_input
  tags: [selection]

- name: Set distribution_selection based on user input
  ansible.builtin.set_fact:
  distribution_selection: "{{ user_input.user_input }}"
  when: user_input.user_input is defined
  tags: [selection]

- name: Set default values for build_rhel8 and build_rhel9
  ansible.builtin.set_fact:
  build_rhel8: false
  build_rhel9: false
  when: build_rhel8 is not defined or build_rhel9 is not defined
  tags: [selection]

- name: Filter available environments based on distribution selection
  block:
  - name: Get all available environments
  ansible.builtin.find:
  paths: "environments"
  file_type: directory
  register: all_environments
  tags: [selection]

- name: Process environments for filtering
  ansible.builtin.set_fact:
  rhel8_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel8') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
  rhel9_environments: "{{ all_environments.files | selectattr('path', 'search', 'rhel9') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
  neutral_environments: "{{ all_environments.files | rejectattr('path', 'search', 'rhel[89]') | rejectattr('path', 'search', '\\.bak$') | map(attribute='path') | list }}"
  tags: [selection]

- name: Set available environments based on distribution selection
  ansible.builtin.set_fact:
  available_environments: >-
    {{
    (distribution_selection == '8') | ternary(rhel8_environments, []) +
    (distribution_selection == '9') | ternary(rhel9_environments, []) +
    (distribution_selection == 'all') | ternary(rhel8_environments + rhel9_environments, []) +
    neutral_environments
    }}
  tags: [selection]
  tags: [selection]

    # Create a formatted list for display purposes
- name: Create formatted environment list
  ansible.builtin.set_fact:
  formatted_env_list: |
  Available environments for selection:
    {% for env in available_environments %}
    {{ loop.index }}. {{ env | basename }}
    {% endfor %}
  tags: [selection]
  when: available_environments is defined and available_environments | length > 0

    # Force display the list with msg parameter
- name: Display available environments (always show)
  ansible.builtin.debug:
  msg: "{{ formatted_env_list.split('\n') }}"
  tags: [selection]
  when: formatted_env_list is defined

    # Combine display and prompt in one step
- name: Prompt for environment selection with display
  ansible.builtin.pause:
  prompt: |
    {{ formatted_env_list }}

  Select environments to build (comma-separated numbers, or 'all'):
  Example: 1,3,5 or all
  register: env_selection
  tags: [selection]
  when: available_environments is defined and available_environments | length > 0

- name: Process environment selection
  block:
  - name: Set selected_environments when 'all' is chosen
  ansible.builtin.set_fact:
  selected_environments: "{{ available_environments }}"
  when: env_selection.user_input | lower == 'all'
  tags: [selection]

- name: Set selected_environments based on numeric selection
  ansible.builtin.set_fact:
  selected_environments: "{{ env_selection.user_input.split(',') | map('trim') | map('int') | map('extract', available_environments, 0, item | int - 1) | list }}"
  when: env_selection.user_input | lower != 'all'
  tags: [selection]

- name: Show selected environments
  ansible.builtin.debug:
  msg: |
  Selected environments to build:
    {% for env in selected_environments %}
- {{ env | basename }}
    {% endfor %}
  tags: [selection]

- name: Determine if running in WSL
  ansible.builtin.shell: |
    grep -q Microsoft /proc/version 2>/dev/null || grep -q WSL /proc/version 2>/dev/null
  register: is_wsl
  changed_when: false
  failed_when: false

- name: Set WSL fact
  ansible.builtin.set_fact:
  is_wsl_env: "{{ is_wsl.rc == 0 }}"
  is_wsl_version: "{{ is_wsl.stdout }}"

- name: Show detailed monitoring connection instructions
  ansible.builtin.debug:
  msg: |
    ┌────────────────────────────────────────────────────────────┐
    │ MONITORING SESSION READY │
    ├────────────────────────────────────────────────────────────┤
    │ │
  │ HOW TO VIEW THE BUILD MONITOR: │
    │ │
  │ Option 1: Use tmux directly │
    │ 1. Open a new terminal tab or window │
  │ 2. Run this command: │
    │ tmux attach -t podman-monitor │
    │ │
  │ Option 2: Use helper script │
    │ 1. Open a new terminal tab or window │
  │ 2. Run: ~/tmux-connect.sh │
    │ │
  │ Monitor Status: Active │
    │ │
    └────────────────────────────────────────────────────────────┘
  changed_when: false
  tags: [monitoring]

- name: Start monitoring with selected environments
  ansible.builtin.shell: |
    ENVS=$(echo "{{ selected_environments | map('basename') | join('\n') }}")
    {{ playbook_dir }}/scripts/start_monitor.sh "$ENVS"
  changed_when: true
  tags: [monitoring]

  when: available_environments is defined and available_environments | length > 0 and env_selection.user_input is defined
  tags: [selection]

- name: Create process_environment.yml dynamically in tasks/ folder
  ansible.builtin.file:
  path: "{{ playbook_dir }}/tasks"
  state: directory
  mode: '0755'
  tags: [setup, build]

- name: Fix container builds by adding environment-specific assemble scripts
  block:
  - name: Create script directories for all environments
  ansible.builtin.file:
  path: "/tmp/ee-containers/context/environments/{{ item | basename }}/scripts"
  state: directory
  force: false
  mode: '0755'
  loop: "{{ selected_environments }}"

- name: Create common assemble script for all environments
  ansible.builtin.template:
  src: "{{ playbook_dir }}/templates/assemble.sh.j2"
  dest: "/tmp/ee-containers/context/environments/{{ item | basename }}/scripts/assemble"
  force: false
  mode: '0755'
  loop: "{{ selected_environments }}"

- name: Create execution environment directories if they don't exist
  ansible.builtin.file:
  path: "{{ playbook_dir }}/environments/{{ item | basename }}"
  state: directory
  mode: '0755'
  loop: "{{ selected_environments }}"

- name: Create basic execution-environment.yml if missing
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/environments/{{ item | basename }}/execution-environment.yml"
  content: |
---
version: 3

images:
base_image:
  - name: registry.redhat.io/ansible-automation-platform-25/ee-minimal-rhel{{ '9' if item | basename is search('rhel9') else '8' }}:latest

  dependencies:
  python:
  - "kubernetes>=12.0.0"
  system:
  - which
  galaxy:
  collections: []

  additional_build_steps:
  prepend_base:
  - USER root
- COPY scripts/assemble /output/scripts/assemble
- RUN chmod +x /output/scripts/assemble
  force: false # Don't overwrite if exists
  loop: "{{ selected_environments }}"

    # Create required dependency files
- name: Create requirements.yml for each environment
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/environments/{{ item | basename }}/requirements.yml"
  content: |
---
collections:
  - ansible.builtin
- community.general
force: false # Don't overwrite if exists
loop: "{{ selected_environments }}"

- name: Create requirements.txt for each environment
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/environments/{{ item | basename }}/requirements.txt"
  content: |
    kubernetes>=12.0.0
    PyYAML>=5.1
    jmespath>=1.0.0
    {% if 'terraform' in item | basename %}
    python-terraform>=0.10.1
    {% endif %}
    {% if 'servicenow' in item | basename %}
    pysnow>=0.8.0
    {% endif %}
  force: false # Don't overwrite if exists
  loop: "{{ selected_environments }}"

- name: Create bindep.txt for each environment
  ansible.builtin.copy:
  dest: "{{ playbook_dir }}/environments/{{ item | basename }}/bindep.txt"
  content: |
  which [platform:rpm]
  curl [platform:rpm]
    {% if 'terraform' in item | basename %}
  unzip [platform:rpm]
  wget [platform:rpm]
    {% endif %}
  force: false # Don't overwrite if exists
  loop: "{{ selected_environments }}"

- name: Copy all environment files to build context
  ansible.builtin.shell: |
    cp -r {{ playbook_dir }}/environments/{{ item | basename }}/* /tmp/ee-containers/context/environments/{{ item | basename }}/
  loop: "{{ selected_environments }}"
  changed_when: true

- name: Create directories in /tmp/ee-containers/context
  ansible.builtin.file:
  path: "/tmp/ee-containers/context/environments/{{ item | basename }}"
  state: directory
  mode: '0755'
  loop: "{{ selected_environments }}"

- name: Copy execution-environment.yml to build context
  ansible.builtin.copy:
  src: "{{ playbook_dir }}/environments/{{ item | basename }}/execution-environment.yml"
  dest: "/tmp/ee-containers/context/environments/{{ item | basename }}/execution-environment.yml"
  mode: '0644'
  remote_src: true
  loop: "{{ selected_environments }}"

- name: Process each selected environment
  ansible.builtin.include_tasks:
  file: "{{ playbook_dir }}/tasks/process_environment.yml"
  loop: "{{ selected_environments }}"
  loop_control:
  loop_var: ee_environment # VERIFY this is ee_environment
  label: "{{ ee_environment | basename }}"
  register: build_results_all
  tags: [build]

- name: Consolidated registry authentication
  block:
  - name: Load credentials if they exist
  ansible.builtin.include_vars:
  file: "{{ user_home }}/.ansible/vars/config"
  ignore_errors: true

- name: Set credential status
  ansible.builtin.set_fact:
  has_valid_credentials: "{{ rh_username is defined and
    rh_username | default('') != '' and
    rh_password is defined and
    rh_password | default('') != '' }}"

- name: Login to registries with credentials
  ansible.builtin.shell: |
    podman login {{ item }} -u '{{ rh_username }}' -p '{{ rh_password }}' --tls-verify=false
  register: registry_login
  with_items: "{{ container_registries }}"
  changed_when: "'Login Succeeded' in registry_login.stdout"
  failed_when: false
  no_log: true
  when: has_valid_credentials | bool

- name: Show registry authentication status
  ansible.builtin.debug:
  msg: "{{ has_valid_credentials | ternary('Registry authentication successful', 'Registry authentication skipped - no valid credentials') }}"
  tags: [registry, build]

- name: Consolidated terminal launch
  block:
  - name: Ensure monitoring session exists
  ansible.builtin.shell: |
    if ! tmux has-session -t podman-monitor 2>/dev/null; then
    echo "Creating monitoring session..."
    {{ playbook_dir }}/scripts/start_monitor.sh
    sleep 2
    fi
  changed_when: true

- name: Launch terminal window (only once)
  ansible.builtin.shell: |
    {{ playbook_dir }}/scripts/open_terminal.sh {{ is_wsl_env | default(false) }}
  register: terminal_launch
  changed_when: terminal_launch.rc == 0
  failed_when: false
  ignore_errors: true
  tags: [monitoring]

  # Play 4: Summary and Status Report
- name: Summary and Status Report
- hosts: localhost
  connection: local
  gather_facts: false
  tasks:
  - name: Generate build summary report
  ansible.builtin.debug:
  msg: |
    ┌──────────────────────────────────────────────────────────────────────────┐
    │ EXECUTION ENVIRONMENT BUILD REPORT │
    ├──────────────────────────────────────────────────────────────────────────┤
    │ STATUS │ ENVIRONMENT │
    ├──────────────────────────────────────────────────────────────────────────┤
    {% for result in build_results | default([]) %}
    │ {{ '[PASS] PASS' if result.success else '[FAIL] FAIL' }} │ {{ '%-65s' | format(result.image) }} │
    {% else %}
    │ No environments were built │
    {% endfor %}
    └──────────────────────────────────────────────────────────────────────────┘

    {% set successful = build_results | default([]) | selectattr('success') | list %}
    {% set failed = build_results | default([]) | list %}

  Summary:
  - Total environments processed: {{ build_results | default([]) | length }}
- Successfully built: {{ successful | length }}
- Failed builds: {{ failed | length }}

    {% if failed %}
  Failed environments:
    {% for result in failed %}
- {{ result.image }} (exit code: {{ result.output.rc }})
    {% endfor %}
    {% endif %}
  when: build_results is defined
  tags: [report]

- name: Show no build results message
  ansible.builtin.debug:
  msg: "No build results available. Did you select any environments to build?"
  when: build_results is not defined or build_results | length == 0
  tags: [report]

  # Play 5: Final cleanup
- name: Final cleanup
- hosts: localhost
  connection: local
  gather_facts: false
  tasks:
  - name: Kill existing monitoring tmux session (if any)
  ansible.builtin.command: tmux has-session -t podman-monitor
  register: tmux_monitor_check
  changed_when: false
  failed_when: false
  tags: [cleanup, post_build]

- name: Close existing monitoring tmux session
  ansible.builtin.shell: tmux kill-session -t podman-monitor
  when: tmux_monitor_check.rc == 0
  changed_when: true
  tags: [cleanup, post_build]

- name: Show cleanup results
  ansible.builtin.debug:
  msg: "Cleanup completed: {{ 'No dangling images found' if prune_output.stdout == '' else prune_output.stdout }}"
  tags: [cleanup, post_build]

- name: Final image pruning
  ansible.builtin.shell: podman image prune -f
  register: final_prune
  changed_when: final_prune.stdout is search("deleted")
  tags: [cleanup, post_build]

- name: Clean up generated files
  block:
  - name: Ask for confirmation to clean up files
  ansible.builtin.pause:
  prompt: |
    Do you want to clean up all generated files and directories?
  This will remove everything except for:
  - README.md
- environments/ directory (your EE definitions)
- site.yml (this playbook)

    Enter 'yes' to clean up, or anything else to keep files
  register: cleanup_confirmation

- name: Remove generated files and directories
  ansible.builtin.file:
  path: "{{ playbook_dir }}/{{ item }}"
  state: absent
  loop:
  - "templates"
- "library"
- "tasks"
- "scripts"
- "files"
- "/tmp/ee-containers"
  when: cleanup_confirmation.user_input == "yes"

- name: Show cleanup results
  ansible.builtin.debug:
  msg: "{{ 'Files cleaned up successfully.' if cleanup_confirmation.user_input == 'yes' else 'Files were kept.' }}"
  tags: [cleanup, post_build]
